<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Record life and work">
<meta property="og:type" content="website">
<meta property="og:title" content="Blog">
<meta property="og:url" content="https://yingjuhan.github.io/Hexo-Blog/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="Record life and work">
<meta property="og:locale">
<meta property="article:author" content="YingjuHan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/Hexo-Blog/atom.xml" title="Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/Hexo-Blog/favicon.png">
  
  
  
<link rel="stylesheet" href="/Hexo-Blog/css/style.css">

  
    
<link rel="stylesheet" href="/Hexo-Blog/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/Hexo-Blog/" id="logo">Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/Hexo-Blog/">Home</a>
        
          <a class="main-nav-link" href="/Hexo-Blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/Hexo-Blog/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yingjuhan.github.io/Hexo-Blog"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-flatbuffers" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/05/30/flatbuffers/" class="article-date">
  <time class="dt-published" datetime="2025-05-30T03:57:01.000Z" itemprop="datePublished">2025-05-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/IO/">IO</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/05/30/flatbuffers/">flatbuffers</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>FlatBuffers 是一个开源的、跨平台的、高效的、提供了多种语言接口的序列化工具库。实现了与 Protocal Buffers 类似的序列化格式。主要由 Wouter van Oortmerssen 编写，并由 Google 开源。Oortmerssen 最初为 Android 游戏和注重性能的应用而开发了 FlatBuffers，现在它具有 C ++、C＃、C、Go、Java、PHP、Python 和 JavaScript 的接口。</p>
<h1 id="2-FlatBuffers-Scheme"><a href="#2-FlatBuffers-Scheme" class="headerlink" title="2. FlatBuffers Scheme"></a>2. FlatBuffers Scheme</h1><p>FlatBuffers 通过 Scheme 文件定义数据结构，Schema 定义与其他框架使用的IDL(Interface description language)语言类似简单易懂，FlatBuffers 的 Scheme 是一种类 C 的语言（尽管 FlatBuffers 有自己的接口定义语言 Scheme 来定义要与之序列化的数据，但它也支持 Protocol Buffers 中的 .proto 格式）。下面以官方 Tutorial 中的 monster.fbs 为例进行说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example IDL file for our monster&#x27;s schema.</span></span><br><span class="line">namespace MyGame.Sample;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>:</span>byte &#123; Red = <span class="number">0</span>, Green, Blue = <span class="number">2</span> &#125;</span><br><span class="line"><span class="keyword">union</span> Equipment &#123; Weapon &#125; <span class="comment">// Optionally add more tables.</span></span><br><span class="line"><span class="keyword">struct</span> Vec3 &#123;</span><br><span class="line">  x:<span class="type">float</span>;</span><br><span class="line">  y:<span class="type">float</span>;</span><br><span class="line">  z:<span class="type">float</span>;</span><br><span class="line">&#125;</span><br><span class="line">table Monster &#123;</span><br><span class="line">  pos:Vec3;</span><br><span class="line">  mana:<span class="type">short</span> = <span class="number">150</span>;</span><br><span class="line">  hp:<span class="type">short</span> = <span class="number">100</span>;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  friendly:<span class="type">bool</span> = <span class="literal">false</span> (deprecated);</span><br><span class="line">  inventory:[ubyte];</span><br><span class="line">  color:Color = Blue;</span><br><span class="line">  weapons:[Weapon];</span><br><span class="line">  equipped:Equipment;</span><br><span class="line">  path:[Vec3];</span><br><span class="line">&#125;</span><br><span class="line">table Weapon &#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  damage:<span class="type">short</span>;</span><br><span class="line">&#125;</span><br><span class="line">root_type Monster;</span><br></pre></td></tr></table></figure>

<p>namespace MyGame.Sample;</p>
<p>namespace 定义命名空间，可以定义嵌套的命名空间，用 . 分割。</p>
<p>enum Color:byte { Red &#x3D; 0, Green, Blue &#x3D; 2 };</p>
<p>enum 定义枚举类型。和常规的枚举类稍有不同的地方是可以定义类型。比如这里的 Color 是 byte 类型。enum 字段只能新增，不能废弃。</p>
<p>union Equipment {Weapon} &#x2F;&#x2F; Optionally add more tables</p>
<p>union 类似 C&#x2F;C++ 中的概念，一个 union 中可以放置多种类型，共同使用一个内存区域。这里的使用是互斥的，即这块内存区域只能由其中一种类型使用。相对 struct 来说比较节省内存。union 跟 enum 比较类似，但是 union 包含的是 table，enum 包含的是 scalar 或者 struct。union 也只能作为 table 的一部分，不能作 root type。</p>
<p>struct Vect3{ x : float; y : float; z : float;};</p>
<p>struct 所有字段都是必填的，因此没有默认值。字段也不能添加或者废弃，且只能包含标量或者其他 struct。struct 主要用于数据结构不会发生改变的场景，相对 table 使用更少的内存，lookup 的时候速度更快（struct 保存在父 table 中，不需要使用 vtable）。</p>
<p>table Monster{};</p>
<p>table 是在 FlatBuffers 中定义对象的主要方式，由一个名称（这里是 Monster）和一个字段列表组成。可以包含上面定义的所有类型。每个字段（Field）包括名称、类型和默认值三部分；每个字段都有默认值，如果没有明确写出则默认为 0 或者 null。每个字段都不是必须的，可以为每个对象选择要省略的字段，这是 FlatBuffers 向前和向后兼容的机制。</p>
<p>root_type Monster;</p>
<p>用于指定序列化后的数据的 root table。<br><img src="/Hexo-Blog/root_table.png" alt="logo"><br>Scheme 设计需要特别注意的：</p>
<p>新字段只能加在 table 的后面。旧代码会忽略这个字段，仍然可以正常执行。新代码读取旧的数据，会取到新增字段的默认值。<br>即使字段不再使用了也不能从 Scheme 中删除。可以标记为 deprecated，在生成代码的时候不会生成该字段的访问器。<br>如果需要嵌套的 vector，可以将 vector 包装在 table 中。string 对于其他编码可以使用 [byte] 或者 [ubyte] 支持。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/05/30/flatbuffers/" data-id="cmbc76opc0020kmq4cos8ajav" data-title="flatbuffers" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/buffer/" rel="tag">buffer</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/file-io/" rel="tag">file io</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-MSVC与MinGW" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/10/MSVC%E4%B8%8EMinGW/" class="article-date">
  <time class="dt-published" datetime="2025-02-10T01:56:28.000Z" itemprop="datePublished">2025-02-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>►<a class="article-category-link" href="/Hexo-Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/10/MSVC%E4%B8%8EMinGW/">MSVC与MinGW</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MSVC与MinGW"><a href="#MSVC与MinGW" class="headerlink" title="MSVC与MinGW"></a>MSVC与MinGW</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>在Windows上编译C&#x2F;C++通常会用到两种工具链<br>MinGW (Minimalist GNU for Windows)和MSVC (Microsoft Visual C++)</p>
<h2 id="2-区别"><a href="#2-区别" class="headerlink" title="2. 区别"></a>2. 区别</h2><h3 id="2-1-编译器"><a href="#2-1-编译器" class="headerlink" title="2.1 编译器"></a>2.1 编译器</h3><ol>
<li>MinGW 使用GNU编译器集合（GCC）的变体，它是一个开源的编译器工具链，支持多种编程语言。MinGW 的编译器通常被称为 GCC 或 G++。</li>
<li>MSVC 使用 Microsoft 的专有编译器，该编译器是 Visual Studio 集成开发环境（IDE）或 Visual Studio 生成工具的一部分，通常称为 cl.exe。</li>
</ol>
<h3 id="2-2-标准库"><a href="#2-2-标准库" class="headerlink" title="2.2 标准库"></a>2.2 标准库</h3><ol>
<li>MinGW 通常使用 GNU 的标准 C 库（glibc）或 MinGW-w64 中的 C 运行时库。它还可以使用 MinGW 专用的头文件和库，以便在 Windows 上开发。</li>
<li>MSVC 使用 Microsoft 的 C 运行时库（CRT），这意味着它具有与 Windows API 更好的集成，但在一些情况下可能不够跨平台。</li>
</ol>
<h3 id="2-3-开发环境"><a href="#2-3-开发环境" class="headerlink" title="2.3 开发环境"></a>2.3 开发环境</h3><ol>
<li>MinGW 通常以类 Unix 的方式工作，可以使用命令行或与其他开发工具集成</li>
<li>MSVC 通常与 Visual Studio IDE (提供了一种集成的开发环境，具有丰富的图形用户界面和调试工具) 或 Visual Studio 生成工具 一起使用。</li>
</ol>
<h3 id="2-4-库依赖"><a href="#2-4-库依赖" class="headerlink" title="2.4 库依赖"></a>2.4 库依赖</h3><ol>
<li><p>库文件格式：<br> MinGW 使用的是 GNU 工具链，因此它通常使用与 GNU 标准库兼容的库文件格式。这些库文件具有以  .a  为扩展名的静态库和以 .dll 为扩展名的动态链接库。<br> MSVC 使用 Microsoft 的 C&#x2F;C++ 标准库格式，这些库文件通常以  .lib 为扩展名，但也可以包含 .dll 动态链接库文件。</p>
</li>
<li><p>库的兼容性：<br> MinGW 生成的库文件通常与 MSVC 生成的库文件不兼容。这意味着你不能将 MinGW 生成的对象文件与 MSVC 生成的库文件链接，反之亦然。<br> 如果你使用 MinGW 编译你的应用程序，你需要确保你使用的库是专门为 MinGW 编译的，或者在构建库时采用兼容的编译选项。<br> 同样，如果你使用 MSVC 编译，你需要使用与 MSVC 兼容的库文件。</p>
</li>
<li><p>第三方库支持：<br> 一些第三方库可能会提供适用于 MinGW 和 MSVC 的不同版本。在选择库时，你需要确保选择与你的编译器兼容的版本。<br> 有些库可能提供了 CMake 或其他构建工具的支持，这些工具可以帮助你在不同的编译器下进行构建。</p>
</li>
</ol>
<h2 id="3-运行时库"><a href="#3-运行时库" class="headerlink" title="3. 运行时库"></a>3. 运行时库</h2><h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>运行时库(RunTime Library)是一组标准化的软件函数集合, 是程序运行时用于支持程序运行所需的一些函数和数据的库。</p>
<h3 id="3-2-运行时库链接方式"><a href="#3-2-运行时库链接方式" class="headerlink" title="3.2 运行时库链接方式"></a>3.2 运行时库链接方式</h3><p>运行时库链接方式有两种：</p>
<ol>
<li>静态链接：<br> 静态链接是指在编译时将运行时库的代码直接嵌入到可执行文件中。这样做目标工程的编译产物更大，因为它包含了所有的运行时库代码。但是它不依赖外部的库文件, 提高了应用的独立性, 并且便于部署.</li>
<li>动态链接：<br> 动态链接是指在编译时不将运行时库(通常是动态链接库DLL或共享对象SO)的代码直接嵌入到可执行文件中，而是在程序运行时才加载运行时库。这样做的好处是多个程序可以共享相同的运行时库，从而减少内存占用。动态链接的目标工程的编译产物更小，因为它只包含了可执行文件的代码和数据，而不包含运行时库的代码, 实现对库文件的共享使用, 节省系统资源。</li>
</ol>
<h3 id="3-3-链接方式的选择"><a href="#3-3-链接方式的选择" class="headerlink" title="3.3 链接方式的选择"></a>3.3 链接方式的选择</h3><ol>
<li>部署简易性: 如果需要简化部署过程, 不希望处理外部的运行时库依赖, 则可以选择静态链接方式;</li>
<li>体积和资源占用: 如果对可执行文件的体积和内存占用有严格要求, 动态链接可以减少重复的库代码占用;</li>
<li>更新与维护: 动态链接便于库文件的更新和维护, 特别是当涉及到安全更新和修复时;</li>
<li>兼容性: 动态链接兼容性可能更好, 因为它保证了与系统的兼容性和一致性;</li>
<li>特殊需求: 对于需要插件或按需加载功能的应用, 运行时动态链接或延迟加载等技术更合适.</li>
</ol>
<h3 id="3-4-MSVC实战"><a href="#3-4-MSVC实战" class="headerlink" title="3.4 MSVC实战"></a>3.4 MSVC实战</h3><p>MSVC的编译选项MT、MD、MTd、MDd指定了程序是静态链接还是动态链接, 以及是否是调试版本的库.</p>
<ul>
<li>MT： mutithread  Static，多线程库，编译器会从运行时库里面选择多线程静态连接库来解释程序中的代码，即连接LIBCMT.lib库</li>
<li>MTd：mutithread debug Static ，多线程调试版，连接LIBMITD.lib库</li>
<li>MD：mutithread  +Dynamic，多线程动态库，连接MSVCRT.lib库，这是个导入库，对应动态库为MSVCRT.dll</li>
<li>MDd： mutithread +Dynamic+debug，多线程动态调试库，连接MSVCRTD.lib库，对应动态库为MSVCRTD.dll</li>
</ul>
<p>MT: Multi-Threaded和MD: Multi-Threaded DLL。<br>早期的 Microsoft Visual C++ 版本中，存在单线程版本的运行时库，这些运行时库不支持多线程程序，从 Visual Studio 2005 开始，所有的运行时库都是多线程的（MT 或 MD），单线程的运行时库已经被淘汰。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>MT&#x2F;MTd（静态链接）的优点是不需要在部署时包含额外的运行时库DLL文件，因为所有的运行时代码都已经包含在最终的可执行文件中。这简化了部署过程并减少了对环境的依赖。缺点是最终的可执行文件会比较大（因为把运行时库二进制也带进来了），如果项目中多个库使用了静态链接运行时库，也会出现重复的、冗余的代码占用内存。</li>
<li>MD&#x2F;MDd（动态链接）的优点是可执行文件体积较小，多个程序可以共享同一份运行时库的副本，节省资源。缺点是在部署程序时需要确保正确版本的运行时库DLL文件也被安装在目标系统上，否则程序无法运行。</li>
</ul>
<h3 id="3-5-常见问题"><a href="#3-5-常见问题" class="headerlink" title="3.5 常见问题"></a>3.5 常见问题</h3><ol>
<li><p>如果使用动态链接，但是没有打包运行时库会怎样？<br> 许多开发者都可能遇到忘记打包运行时库的场景，表现上是在自己电脑上正常运行，但是发布到其他电脑上提示找不到xxx.dll，</p>
 <img src="/Hexo-Blog/2025/02/10/MSVC%E4%B8%8EMinGW/not_found_runtime140_1.png" class="" title="not_found_runtime140_1.dll">
<p> 网上也提供了很多接近方案，例如VC Runtime 集合，包含了各种版本的 Visual C++ 运行时库的集合。如果一个应用程序是使用特定版本的 Visual Studio 编译的，并且使用了动态链接库（DLL），那么它就需要相应版本的 VC Runtime 来确保正确运行。</p>
<p> VC Runtime 集合的出现主要是为了解决以下问题：</p>
<ul>
<li>版本兼容：不同的应用程序可能需要不同版本的 VC Runtime。一个集合包含了多个版本的运行时库，可以确保大多数应用程序的兼容性。</li>
<li>简化安装：用户可以一次性安装多个版本的 VC Runtime，而不需要单独下载和安装每个应用程序需要的特定版本。</li>
<li>解决缺失：如果用户遇到因为缺少 VC Runtime 导致的问题，安装集合包可以快速解决缺失的库文件问题。<br> 从某种角度上来说，VC Runtime 集合的存在并不直接代表软件开发者没有正确打包动态运行时库，而是因为操作系统或软件的多样性和复杂性，使得拥有一个集合包来解决潜在的兼容性问题变得更加方便和必要。不过，为了减少不必要的用户反馈，最佳实践仍然是我们在软件分发时包括所有必要的依赖，确保自己的软件不出现运行时库的缺少的问题。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/10/MSVC%E4%B8%8EMinGW/" data-id="cmbc76op9001qkmq4a5au3hap" data-title="MSVC与MinGW" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C/" rel="tag">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/MSVC/" rel="tag">MSVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/MinGW/" rel="tag">MinGW</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-a和so的简介-3-Linux-GNU" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/09/a%E5%92%8Cso%E7%9A%84%E7%AE%80%E4%BB%8B-3-Linux-GNU/" class="article-date">
  <time class="dt-published" datetime="2025-02-09T12:11:41.000Z" itemprop="datePublished">2025-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/C-C-%E5%9F%BA%E7%A1%80/">C/C++基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/09/a%E5%92%8Cso%E7%9A%84%E7%AE%80%E4%BB%8B-3-Linux-GNU/">.a和so的简介 (3. Linux GNU)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>以下是如何使用 CMake 来生成静态库（<code>.a</code> 文件）和动态库（<code>.so</code> 文件）的详细教程，结合如何在其他项目中使用这些库。</p>
<h3 id="1-创建静态库和动态库"><a href="#1-创建静态库和动态库" class="headerlink" title="1. 创建静态库和动态库"></a>1. 创建静态库和动态库</h3><p>首先，创建一个包含库代码的项目。假设库代码位于 <code>MyLibrary</code> 目录下，源代码文件为 <code>mylib.cpp</code>，头文件为 <code>mylib.h</code>。</p>
<h4 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1. 目录结构"></a>1.1. 目录结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/MyLibrary</span><br><span class="line">  /src</span><br><span class="line">    mylib.cpp</span><br><span class="line">    mylib.h</span><br><span class="line">  CMakeLists.txt</span><br><span class="line">  /build</span><br></pre></td></tr></table></figure>

<h4 id="1-2-库的源代码-mylib-cpp"><a href="#1-2-库的源代码-mylib-cpp" class="headerlink" title="1.2. 库的源代码 mylib.cpp"></a>1.2. 库的源代码 <code>mylib.cpp</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylib.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from MyLibrary!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-库的头文件-mylib-h"><a href="#1-3-库的头文件-mylib-h" class="headerlink" title="1.3. 库的头文件 mylib.h"></a>1.3. 库的头文件 <code>mylib.h</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mylib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYLIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYLIB_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MYLIB_H</span></span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-CMakeLists-txt-文件"><a href="#1-4-CMakeLists-txt-文件" class="headerlink" title="1.4. CMakeLists.txt 文件"></a>1.4. <code>CMakeLists.txt</code> 文件</h4><p>在 <code>MyLibrary</code> 根目录下创建 <code>CMakeLists.txt</code> 文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 CMake 最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyLibrary)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项：用户可以选择构建静态库或动态库</span></span><br><span class="line"><span class="keyword">option</span>(BUILD_STATIC_LIBS <span class="string">&quot;Build static libraries&quot;</span> <span class="keyword">OFF</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出目录</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据选项决定是生成静态库还是动态库</span></span><br><span class="line"><span class="keyword">if</span>(BUILD_STATIC_LIBS)</span><br><span class="line">    <span class="keyword">add_library</span>(mylib STATIC src/mylib.cpp)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">add_library</span>(mylib SHARED src/mylib.cpp)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件目录</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(mylib PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src)</span><br></pre></td></tr></table></figure>

<h4 id="1-5-生成库"><a href="#1-5-生成库" class="headerlink" title="1.5. 生成库"></a>1.5. 生成库</h4><p>在命令行中运行以下命令来生成静态库或动态库：</p>
<ol>
<li><strong>生成动态库</strong>（默认）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>CMake 会在 <code>build/lib/</code> 目录下生成 <code>libmylib.so</code> 文件。</p>
<ol start="2">
<li><strong>生成静态库</strong>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DBUILD_STATIC_LIBS=ON ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>CMake 会在 <code>build/lib/</code> 目录下生成 <code>libmylib.a</code> 文件。</p>
<h3 id="2-在另一个项目中使用库"><a href="#2-在另一个项目中使用库" class="headerlink" title="2. 在另一个项目中使用库"></a>2. 在另一个项目中使用库</h3><p>假设已经生成了 <code>libmylib.a</code>（静态库）或 <code>libmylib.so</code>（动态库），现在创建一个新的项目来使用这个库。</p>
<h4 id="2-1-目录结构"><a href="#2-1-目录结构" class="headerlink" title="2.1. 目录结构"></a>2.1. 目录结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ClientProject</span><br><span class="line">  /src</span><br><span class="line">    main.cpp</span><br><span class="line">  CMakeLists.txt</span><br><span class="line">  /build</span><br></pre></td></tr></table></figure>

<h4 id="2-2-main-cpp-文件"><a href="#2-2-main-cpp-文件" class="headerlink" title="2.2. main.cpp 文件"></a>2.2. <code>main.cpp</code> 文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mylib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hello</span>();  <span class="comment">// 调用 MyLibrary 中的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-CMakeLists-txt-文件"><a href="#2-3-CMakeLists-txt-文件" class="headerlink" title="2.3. CMakeLists.txt 文件"></a>2.3. <code>CMakeLists.txt</code> 文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 CMake 最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(ClientProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(clientApp src/main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接 MyLibrary 静态库或动态库</span></span><br><span class="line"><span class="comment"># 假设 MyLibrary 的生成库位于 ../MyLibrary/build/lib</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(clientApp PRIVATE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../MyLibrary/build/lib/libmylib.a) <span class="comment"># 静态库链接</span></span><br><span class="line"><span class="comment"># target_link_libraries(clientApp PRIVATE $&#123;CMAKE_SOURCE_DIR&#125;/../MyLibrary/build/lib/libmylib.so) # 动态库链接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含 MyLibrary 的头文件</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(clientApp PRIVATE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../MyLibrary/src)</span><br></pre></td></tr></table></figure>

<h4 id="2-4-生成并运行"><a href="#2-4-生成并运行" class="headerlink" title="2.4. 生成并运行"></a>2.4. 生成并运行</h4><p>进入 <code>ClientProject/build</code> 目录，运行以下命令生成并运行可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>如果使用静态库，生成的可执行文件可以直接运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./clientApp</span><br></pre></td></tr></table></figure>

<p>如果使用动态库，需要确保 <code>.so</code> 文件在运行时能被找到。可以将动态库拷贝到可执行文件目录，或者设置 <code>LD_LIBRARY_PATH</code> 环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/path/to/your/lib:<span class="variable">$LD_LIBRARY_PATH</span></span><br><span class="line">./clientApp</span><br></pre></td></tr></table></figure>

<h3 id="3-CMake-管理-a-和-so-的自动选择"><a href="#3-CMake-管理-a-和-so-的自动选择" class="headerlink" title="3. CMake 管理 .a 和 .so 的自动选择"></a>3. CMake 管理 <code>.a</code> 和 <code>.so</code> 的自动选择</h3><p>还可以使用 CMake 的 <code>find_library()</code> 函数，自动选择静态库或动态库：</p>
<h4 id="修改-ClientProject-的-CMakeLists-txt"><a href="#修改-ClientProject-的-CMakeLists-txt" class="headerlink" title="修改 ClientProject 的 CMakeLists.txt"></a>修改 <code>ClientProject</code> 的 <code>CMakeLists.txt</code></h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 CMake 最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(ClientProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 MyLibrary 库，自动选择静态库或动态库</span></span><br><span class="line"><span class="keyword">find_library</span>(MYLIBRARY_LIB NAMES mylib PATHS <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../MyLibrary/build/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(clientApp src/main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接找到的库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(clientApp PRIVATE <span class="variable">$&#123;MYLIBRARY_LIB&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含 MyLibrary 的头文件</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(clientApp PRIVATE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../MyLibrary/src)</span><br></pre></td></tr></table></figure>

<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><ol>
<li><strong>静态库 <code>.a</code></strong> 在编译时链接到可执行文件，生成的可执行文件无需在运行时依赖库文件。</li>
<li><strong>动态库 <code>.so</code></strong> 在运行时动态加载，减小了可执行文件的体积，但需要确保库文件在运行时可用。</li>
<li>使用 CMake 生成静态库或动态库时，可以通过选项动态选择，方便管理。</li>
<li>在其他项目中链接库时，可以使用 <code>target_link_libraries()</code> 来链接静态或动态库，并通过 <code>find_library()</code> 来自动查找库文件。</li>
</ol>
<p>通过以上配置，可以在 CMake 项目中灵活使用静态库和动态库。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/09/a%E5%92%8Cso%E7%9A%84%E7%AE%80%E4%BB%8B-3-Linux-GNU/" data-id="cmbc76opa001tkmq4fl2u8jik" data-title=".a和so的简介 (3. Linux GNU)" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C-C-%E5%9F%BA%E7%A1%80/" rel="tag">C&#x2F;C++基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">动态链接库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">静态链接库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DLL-a和DLL的简介-2-Windows-MINGW" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/09/DLL-a%E5%92%8CDLL%E7%9A%84%E7%AE%80%E4%BB%8B-2-Windows-MINGW/" class="article-date">
  <time class="dt-published" datetime="2025-02-09T11:27:05.000Z" itemprop="datePublished">2025-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/C-C-%E5%9F%BA%E7%A1%80/">C/C++基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/09/DLL-a%E5%92%8CDLL%E7%9A%84%E7%AE%80%E4%BB%8B-2-Windows-MINGW/">DLL.a和DLL的简介 (2. Windows MINGW)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="DLL-a和DLL的简介-2-Windows-MINGW"><a href="#DLL-a和DLL的简介-2-Windows-MINGW" class="headerlink" title="DLL.a和DLL的简介 (2. Windows MINGW)"></a>DLL.a和DLL的简介 (2. Windows MINGW)</h1><p>使用 CMake 来配置和生成 DLL 和 <code>.dll.a</code>（导入库）文件非常方便。以下是如何使用 CMake 创建一个动态链接库（DLL）和导入库（<code>.dll.a</code>），并在其他项目中链接它们的详细步骤。</p>
<h2 id="1-创建-DLL-工程"><a href="#1-创建-DLL-工程" class="headerlink" title="1. 创建 DLL 工程"></a>1. 创建 DLL 工程</h2><p>假设有一个动态链接库需要导出函数，并且源代码为 <code>mydll.cpp</code>。通过 CMake 来生成 DLL 和导入库。</p>
<h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h3><p>首先，设置工程目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/Project</span><br><span class="line">  /src</span><br><span class="line">    mydll.cpp</span><br><span class="line">    mydll.h</span><br><span class="line">  CMakeLists.txt</span><br><span class="line">  /build</span><br></pre></td></tr></table></figure>

<h3 id="1-2-源代码-mydll-cpp"><a href="#1-2-源代码-mydll-cpp" class="headerlink" title="1.2 源代码 mydll.cpp"></a>1.2 源代码 <code>mydll.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 __declspec(dllexport) 导出函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from the DLL!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-CMakeLists-txt-文件"><a href="#1-3-CMakeLists-txt-文件" class="headerlink" title="1.3 CMakeLists.txt 文件"></a>1.3 <code>CMakeLists.txt</code> 文件</h3><p>在 <code>Project</code> 根目录下创建 <code>CMakeLists.txt</code> 文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 CMake 最低版本和工程名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(MyDLLProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置输出路径（可选）</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定动态库的源文件</span></span><br><span class="line"><span class="keyword">add_library</span>(mydll SHARED src/mydll.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置导出符号的宏定义，确保 Windows 上导出正确</span></span><br><span class="line"><span class="keyword">if</span> (WIN32)</span><br><span class="line">    <span class="keyword">target_compile_definitions</span>(mydll PRIVATE MYDLL_EXPORTS)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定库文件的输出名称（dll 文件和导入库）</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(mydll PROPERTIES OUTPUT_NAME <span class="string">&quot;mydll&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出头文件供其他项目使用</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(mydll PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src)</span><br></pre></td></tr></table></figure>

<p>在 <code>CMakeLists.txt</code> 中：</p>
<ul>
<li><code>add_library(mydll SHARED src/mydll.cpp)</code>：告诉 CMake 创建一个共享库（动态库，DLL）。</li>
<li><code>set_target_properties(mydll PROPERTIES OUTPUT_NAME &quot;mydll&quot;)</code>：设置输出的 DLL 文件名为 <code>mydll.dll</code>，导入库为 <code>libmydll.dll.a</code>。</li>
<li><code>target_include_directories(mydll PUBLIC $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src)</code>：将头文件目录暴露给其他使用此库的项目。</li>
</ul>
<h3 id="1-4-生成-DLL-和-dll-a-文件"><a href="#1-4-生成-DLL-和-dll-a-文件" class="headerlink" title="1.4 生成 DLL 和 .dll.a 文件"></a>1.4 生成 DLL 和 <code>.dll.a</code> 文件</h3><p>在命令行中执行以下命令生成动态库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>CMake 会在 <code>build/bin/</code> 目录下生成 <code>mydll.dll</code>，并在 <code>build/lib/</code> 目录下生成 <code>libmydll.dll.a</code>。</p>
<h2 id="2-在另一个项目中使用-DLL-和-dll-a"><a href="#2-在另一个项目中使用-DLL-和-dll-a" class="headerlink" title="2. 在另一个项目中使用 DLL 和 .dll.a"></a>2. 在另一个项目中使用 DLL 和 <code>.dll.a</code></h2><p>现在，创建一个新项目来使用刚才生成的动态链接库 <code>mydll.dll</code> 和导入库 <code>libmydll.dll.a</code>。</p>
<h3 id="2-1-目录结构"><a href="#2-1-目录结构" class="headerlink" title="2.1 目录结构"></a>2.1 目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/ClientProject</span><br><span class="line">  /src</span><br><span class="line">    main.cpp</span><br><span class="line">  CMakeLists.txt</span><br><span class="line">  /build</span><br></pre></td></tr></table></figure>

<h4 id="2-2-main-cpp"><a href="#2-2-main-cpp" class="headerlink" title="2.2. main.cpp"></a>2.2. <code>main.cpp</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mydll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span></span>;  <span class="comment">// 导入 DLL 中的函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">hello</span>();  <span class="comment">// 调用 DLL 函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-CMakeLists-txt"><a href="#2-3-CMakeLists-txt" class="headerlink" title="2.3. CMakeLists.txt"></a>2.3. <code>CMakeLists.txt</code></h4><p>在 <code>ClientProject</code> 目录下创建 <code>CMakeLists.txt</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 CMake 最低版本和工程名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="keyword">project</span>(ClientProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(clientApp src/main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接到动态库</span></span><br><span class="line"><span class="comment"># 假设之前生成的 mydll.dll.a 和头文件位于 ../Project/build</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(clientApp PRIVATE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../<span class="keyword">Project</span>/build/lib/libmydll.dll.a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(clientApp PRIVATE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/../<span class="keyword">Project</span>/src)</span><br></pre></td></tr></table></figure>

<p>在这里：</p>
<ul>
<li><code>target_link_libraries(clientApp PRIVATE ../Project/build/lib/libmydll.dll.a)</code>：指定要链接的导入库。</li>
<li><code>target_include_directories(clientApp PRIVATE ../Project/src)</code>：指定头文件的路径，以便编译器能找到 <code>mydll.h</code>。</li>
</ul>
<h4 id="2-4-生成并运行"><a href="#2-4-生成并运行" class="headerlink" title="2.4. 生成并运行"></a>2.4. 生成并运行</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">cmake --build .</span><br></pre></td></tr></table></figure>

<p>运行生成的可执行文件时，确保 <code>mydll.dll</code> 在可执行文件的同一目录下，或将其放在系统路径中。可以将 DLL 复制到 <code>build/bin</code> 目录中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ../Project/build/bin/mydll.dll ./bin/</span><br><span class="line">./bin/clientApp</span><br></pre></td></tr></table></figure>

<p>运行后，程序应输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello from the DLL!</span><br></pre></td></tr></table></figure>

<p>通过以上步骤：</p>
<ol>
<li>使用 CMake 创建了一个包含导入库（<code>.dll.a</code>）和 DLL 文件的动态库项目。</li>
<li>使用了这个 DLL 库，并通过 <code>.dll.a</code> 在另一个项目中链接并调用了 DLL 中的函数。</li>
</ol>
<h1 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h1><p>在使用动态链接库（DLL）时，<code>.a</code> 文件通常是 GCC 或 MinGW 编译器生成的<strong>导入库</strong>（import library），它的作用类似于 MSVC 生成的 <code>.lib</code> 文件。<code>.a</code> 文件用于在<strong>编译时</strong>告诉链接器如何解析 DLL 文件中的符号，而 DLL 文件是在<strong>运行时</strong>加载的。</p>
<p>因此，通常 <code>.a</code> 文件（导入库）应该放在 <code>lib</code> 目录，而 <code>.dll</code> 文件应该放在 <code>bin</code> 目录或可执行文件所在的目录。</p>
<h3 id="具体说明："><a href="#具体说明：" class="headerlink" title="具体说明："></a>具体说明：</h3><ol>
<li><p><strong><code>.a</code> 文件（导入库）</strong>：</p>
<ul>
<li>这是编译时用的文件，通常放在项目的 <code>lib</code> 目录中，因为编译器或链接器会从该目录中查找导入库。</li>
<li><code>lib</code> 目录一般是专门存放静态库和导入库的地方。</li>
</ul>
</li>
<li><p><strong><code>.dll</code> 文件（动态链接库）</strong>：</p>
<ul>
<li>这是运行时用的文件，通常放在 <code>bin</code> 目录中，或者可以将它与可执行文件一起放在同一个目录下。</li>
<li><code>bin</code> 目录通常用来存放可执行文件和动态链接库，程序在运行时会从该目录中加载 DLL 文件。</li>
</ul>
</li>
</ol>
<h3 id="示例目录结构："><a href="#示例目录结构：" class="headerlink" title="示例目录结构："></a>示例目录结构：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/project</span><br><span class="line">  /bin            # 运行时所需文件</span><br><span class="line">    myExecutable.exe</span><br><span class="line">    DLLSample.dll  # DLL 文件放在 bin 目录中</span><br><span class="line">  /lib            # 编译时所需文件</span><br><span class="line">    DLLSample.a    # 导入库放在 lib 目录中</span><br><span class="line">  /include        # 头文件目录</span><br><span class="line">    DLLSample.h    # 头文件放在 include 目录中</span><br><span class="line">  /src            # 源代码</span><br><span class="line">    main.cpp</span><br><span class="line">  CMakeLists.txt</span><br></pre></td></tr></table></figure>

<h3 id="CMake-配置示例："><a href="#CMake-配置示例：" class="headerlink" title="CMake 配置示例："></a>CMake 配置示例：</h3><p>如果使用 CMake 构建项目，可以这样配置：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(myExecutable main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接导入库 (.a)</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(myExecutable PRIVATE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib/DLLSample.a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 DLL 文件的路径</span></span><br><span class="line"><span class="keyword">set_target_properties</span>(myExecutable PROPERTIES</span><br><span class="line">    RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/bin</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要头文件路径</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(myExecutable PRIVATE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>通过这种方式，CMake 会在编译时链接 <code>.a</code> 文件（导入库），并且生成的可执行文件在运行时从 <code>bin</code> 目录加载对应的 <code>.dll</code> 文件。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong><code>.a</code> 文件</strong> 放在 <code>lib</code> 目录，因为它是编译时需要的导入库。</li>
<li><strong><code>.dll</code> 文件</strong> 放在 <code>bin</code> 目录或可执行文件的目录，因为它是运行时需要加载的动态库。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/09/DLL-a%E5%92%8CDLL%E7%9A%84%E7%AE%80%E4%BB%8B-2-Windows-MINGW/" data-id="cmbc76op8001ikmq46if343yp" data-title="DLL.a和DLL的简介 (2. Windows MINGW)" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C-C-%E5%9F%BA%E7%A1%80/" rel="tag">C&#x2F;C++基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">动态链接库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">静态链接库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-LIB和DLL的简介" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/09/LIB%E5%92%8CDLL%E7%9A%84%E7%AE%80%E4%BB%8B/" class="article-date">
  <time class="dt-published" datetime="2025-02-09T10:25:01.000Z" itemprop="datePublished">2025-02-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/C-C-%E5%9F%BA%E7%A1%80/">C/C++基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/09/LIB%E5%92%8CDLL%E7%9A%84%E7%AE%80%E4%BB%8B/">LIB和DLL的简介 (1. Windows MSVC)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="LIB和DLL的简介"><a href="#LIB和DLL的简介" class="headerlink" title="LIB和DLL的简介"></a>LIB和DLL的简介</h1><h2 id="1-动态链接库与静态链接库："><a href="#1-动态链接库与静态链接库：" class="headerlink" title="1. 动态链接库与静态链接库："></a>1. 动态链接库与静态链接库：</h2><ol>
<li>动态链接库dynamic link library: LIB包含了函数所在的DLL文件和文件中函数位置的信息（入口），代码由运行时加载在进程空间中的DLL提供</li>
<li>静态链接库static link library: LIB包含函数代码本身，在编译时直接将代码加入程序当中</li>
</ol>
<h2 id="2-动态链接方式与静态链接方式："><a href="#2-动态链接方式与静态链接方式：" class="headerlink" title="2. 动态链接方式与静态链接方式："></a>2. 动态链接方式与静态链接方式：</h2><ol>
<li>动态链接使用动态链接库，允许可执行模块（.dll文件或.exe文件）仅包含在运行时定位DLL函数的可执行代码所需的信息</li>
<li>静态链接使用静态链接库，链接器从静态链接库LIB获取所有被引用函数，并将库同代码一起放到可执行文件中</li>
</ol>
<h2 id="3-lib和dll的区别如下："><a href="#3-lib和dll的区别如下：" class="headerlink" title="3. lib和dll的区别如下："></a>3. lib和dll的区别如下：</h2><ol>
<li>lib是编译时用到的，dll是运行时用到的。如果要完成源代码的编译，只需要lib；如果要使动态链接的程序运行起来，只需要dll;</li>
<li>如果有dll文件，那么lib一般是一些索引信息，记录了dll中函数的入口和位置，dll中是函数的具体内容；如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。使用静态编译的lib文件，在运行程序时不需要再挂动态库，缺点是导致应用程序比较大，而且失去了动态库的灵活性，发布新版本时要发布新的应用程序才行;</li>
<li>动态链接的情况下，有两个文件：一个是LIB文件，一个是DLL文件。LIB包含被DLL导出的函数名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到DLL文件。在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中相应函数代码的地址，从而节省了内存资源。DLL和LIB文件必须随应用程序一起发行，否则应用程序会产生错误。如果不想用lib文件或者没有lib文件，可以用WIN32 API函数LoadLibrary、GetProcAddress装载;</li>
<li>静态链接的情况下，只有一个LIB文件。在编译链接时，WIN32 Link 将会从LIB文件中寻找相应的函数代码，将它们直接链接到生成的可执行文件或生成的库文件中。</li>
</ol>
<h2 id="4-使用lib需要注意的两个文件"><a href="#4-使用lib需要注意的两个文件" class="headerlink" title="4. 使用lib需要注意的两个文件"></a>4. 使用lib需要注意的两个文件</h2><ol>
<li>H文件：头文件，包含了函数的声明，包含LIB中导出类、符号原型或数据结构,应用程序调用LIB中的函数或访问数据结构时，需要将对应的头文件包含在应用程序中;</li>
<li>LIB文件：库文件，包含函数的实现，应用程序链接LIB文件时，需要将LIB文件包含在应用程序的链接选项中;</li>
</ol>
<h2 id="5-使用dll需要注意的三个文件"><a href="#5-使用dll需要注意的三个文件" class="headerlink" title="5. 使用dll需要注意的三个文件"></a>5. 使用dll需要注意的三个文件</h2><ol>
<li>h头文件，包含dll中说明输出的类或符号原型或数据结构的.h文件。应用程序调用dll时，需要将该文件包含入应用程序的源文件中。</li>
<li>LIB文件，是dll在编译、链接成功之后生成的文件，作用是当其他应用程序调用dll时，需要将该文件引入应用程序，否则产生错误。如果不想用lib文件或者没有lib文件，可以用WIN32 API函数LoadLibrary、GetProcAddress装载。</li>
<li>DLL文件，真正的可执行文件，开发成功后的应用程序在发布时，只需要有可执行文件和DLL文件，并不需要LIB文件和H头文件。</li>
</ol>
<h2 id="6-使用LIB的方法"><a href="#6-使用LIB的方法" class="headerlink" title="6. 使用LIB的方法"></a>6. 使用LIB的方法</h2><p>静态lib中，一个lib文件实际上是任意个obj文件的集合，obj文件是cpp文件编译生成的。在编译这种静态库工程时，根本不会遇到链接错误；即使有错，也只会在使用这个LIB的可执行文件或者库工程里暴露出来。</p>
<h3 id="6-1-创建静态库-MyLib-lib"><a href="#6-1-创建静态库-MyLib-lib" class="headerlink" title="6.1 创建静态库(MyLib.lib)"></a>6.1 创建静态库(MyLib.lib)</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置最低CMake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工程名称</span></span><br><span class="line"><span class="keyword">project</span>(MyLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加源文件</span></span><br><span class="line"><span class="keyword">add_library</span>(MyLib STATIC <span class="keyword">test</span>.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定库的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>
<p>该文件将生成一个静态库 MyLib.lib，并将其放置在 CMake 构建目录下的 lib 文件夹中。</p>
<h3 id="6-2-创建目标工程-并链接静态库"><a href="#6-2-创建目标工程-并链接静态库" class="headerlink" title="6.2 创建目标工程, 并链接静态库"></a>6.2 创建目标工程, 并链接静态库</h3><ul>
<li>法1：将 MyLib.lib 作为外部库添加到目标工程<br>文件夹结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/projectA</span><br><span class="line">  CMakeLists.txt</span><br><span class="line">  main.cpp</span><br><span class="line">  /lib</span><br><span class="line">    MyLib.lib</span><br></pre></td></tr></table></figure>
<p>projectA 是使用静态库 MyLib.lib 的目标工程，需要将 MyLib.lib 作为外部库链接到projectA中。</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置最低CMake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工程名称</span></span><br><span class="line"><span class="keyword">project</span>(projectA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(projectA main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加静态库的路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将静态库链接到工程</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(projectA PRIVATE MyLib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/path/to/lib/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>这样，CMake 会找到 MyLib.lib 并将其链接到 projectA，其中：<br>link_directories() 用于告诉 CMake 该去哪里查找库文件（例如 MyLib.lib）。<br>target_link_libraries() 用于将库 MyLib.lib 链接到目标 projectA。</p>
<ul>
<li>法2: 直接指定静态库的路径</li>
</ul>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置最低CMake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义工程名称</span></span><br><span class="line"><span class="keyword">project</span>(projectA)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加源文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(projectA main.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(projectA PRIVATE <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/lib/Lib.lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/path/to/lib/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>这种方式省略了 link_directories，直接通过库的绝对路径进行链接。</p>
<h2 id="7-使用DLL的方法"><a href="#7-使用DLL的方法" class="headerlink" title="7. 使用DLL的方法"></a>7. 使用DLL的方法</h2><p>使用动态链接中的LIB，不是obj文件的集合，即里面不会有实际的实现，它只是提供动态链接到DLL所需要的信息，这种LIB可以在编译一个DLL工程时由编译器生成。</p>
<h3 id="7-1-创建动态库-MyDLL-dll"><a href="#7-1-创建动态库-MyDLL-dll" class="headerlink" title="7.1 创建动态库(MyDLL.dll)"></a>7.1 创建动态库(MyDLL.dll)</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置最低CMake版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"><span class="comment"># 定义工程名称</span></span><br><span class="line"><span class="keyword">project</span>(MyDLL)</span><br><span class="line"><span class="comment"># 添加源文件</span></span><br><span class="line"><span class="keyword">add_library</span>(MyDLL SHARED <span class="keyword">test</span>.cpp)</span><br><span class="line"><span class="comment"># 指定库的输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/lib)</span><br></pre></td></tr></table></figure>
<p>该文件将生成一个动态库 MyDLL.dll，并将其放置在 CMake 构建目录下的 lib 文件夹中。</p>
<h3 id="7-2-创建目标工程-并链接动态库"><a href="#7-2-创建目标工程-并链接动态库" class="headerlink" title="7.2 创建目标工程, 并链接动态库"></a>7.2 创建目标工程, 并链接动态库</h3><h4 id="7-2-1-隐式链接"><a href="#7-2-1-隐式链接" class="headerlink" title="7.2.1 隐式链接"></a>7.2.1 隐式链接</h4><p>第一种方法是：通过project-&gt;link-&gt;Object&#x2F;Library Module中加入.lib文件（或者在源代码中加入指令#pragma comment(lib, “Lib.lib”)），并将.dll文件置入工程所在目录，然后添加对应的.h头文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myLib.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;MyLib.lib&quot;</span>)    <span class="comment">//你也可以在项目属性中设置库的链接</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="built_in">TestDLL</span>(<span class="number">123</span>);   <span class="comment">//dll中的函数，在MyLib.h中声明</span></span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-2-2-显式链接"><a href="#7-2-2-显式链接" class="headerlink" title="7.2.2 显式链接"></a>7.2.2 显式链接</h4><p>需要函数指针和WIN32 API函数LoadLibrary、GetProcAddress装载，使用这种载入方法，不需要.lib文件和.h头文件，只需要.dll文件即可（将.dll文件置入工程目录中）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span>         <span class="comment">//使用函数和某些特殊变量</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*DLLFunc)</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DLLFunc dllFunc;</span><br><span class="line">        HINSTANCE hInstLibrary = <span class="built_in">LoadLibrary</span>(<span class="string">&quot;MyLib.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hInstLibrary == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">FreeLibrary</span>(hInstLibrary);</span><br><span class="line">        &#125;</span><br><span class="line">        dllFunc = (DLLFunc)<span class="built_in">GetProcAddress</span>(hInstLibrary, <span class="string">&quot;TestDLL&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (dllFunc == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">FreeLibrary</span>(hInstLibrary);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dllFunc</span>(<span class="number">123</span>);</span><br><span class="line">        std::cin.<span class="built_in">get</span>();</span><br><span class="line">        <span class="built_in">FreeLibrary</span>(hInstLibrary);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LoadLibrary函数利用一个名称作为参数，获得DLL的实例（HINSTANCE类型是实例的句柄），通常调用该函数后需要查看一下函数返回是否成功，如果不成功则返回NULL（句柄无效），此时调用函数FreeLibrary释放DLL获得的内存。<br>GetProcAddress函数利用DLL的句柄和函数的名称作为参数，返回相应的函数指针，同时必须使用强转；判断函数指针是否为NULL，如果是则调用函数FreeLibrary释放DLL获得的内存。此后，可以使用函数指针来调用实际的函数。<br>最后要记得使用FreeLibrary函数释放内存。</p>
<p><strong>应用程序如何找到DLL文件？</strong><br>使用LoadLibrary显式链接，那么在函数的参数中可以指定DLL文件的完整路径；如果不指定路径，或者进行隐式链接，Windows将遵循下面的搜索顺序来定位DLL：<br>（1）包含EXE文件的目录<br>（2）工程目录<br>（3）Windows系统目录<br>（4）Windows目录<br>（5）列在Path环境变量中的一系列目录</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/09/LIB%E5%92%8CDLL%E7%9A%84%E7%AE%80%E4%BB%8B/" data-id="cmbc76op8001lkmq4gkizhvm6" data-title="LIB和DLL的简介 (1. Windows MSVC)" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C-C-%E5%9F%BA%E7%A1%80/" rel="tag">C&#x2F;C++基础</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">动态链接库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">静态链接库</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C-Primer-5th-19" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/02/C-Primer-5th-19/" class="article-date">
  <time class="dt-published" datetime="2025-02-02T14:04:33.000Z" itemprop="datePublished">2025-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/C-Primer-5th/">C++ Primer 5th</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/02/C-Primer-5th-19/">C++ Primer 5th 19</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第十九章-特殊工具与技术"><a href="#第十九章-特殊工具与技术" class="headerlink" title="第十九章 特殊工具与技术"></a>第十九章 特殊工具与技术</h1><h2 id="控制内存分配"><a href="#控制内存分配" class="headerlink" title="控制内存分配"></a>控制内存分配</h2><h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><ul>
<li><strong><code>new</code>表达式的工作机理</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;a value&quot;</span>); <span class="comment">//分配并初始化一个string对象</span></span><br><span class="line">string *arr = <span class="keyword">new</span> string[<span class="number">10</span>];   <span class="comment">// 分配10个默认初始化的string对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上述代码实际执行了<strong>三步操作</strong>：</p>
<ul>
<li><code>new</code>表达式调用一个名为<code>operator new</code>(或<code>operator new []</code>)的标准库函数，它分配一块<strong>足够大的</strong>、<strong>原始的</strong>、<strong>未命名的</strong>内存空间以便存储特定类型的对象(或对象的数组)。</li>
<li>编译器运行相应的构造函数以构造这些对象，并为其传入初始值。</li>
<li>对象被分配了空间并构造完成，返回一个指向该对象的指针。</li>
</ul>
</li>
<li><p><strong><code>delete</code>表达式的工作机理</strong>：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> sp;  <span class="comment">// 销毁*sp，然后释放sp指向的内存空间</span></span><br><span class="line"><span class="keyword">delete</span> [] arr;  <span class="comment">// 销毁数组中的元素，然后释放对应的内存空间</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上述代码实际执行了<strong>两步操作</strong>：<ul>
<li>对<code>sp</code>所指向的对象或者<code>arr</code>所指的数组中的元素执行对应的析构函数。</li>
<li>编译器调用名为<code>operator delete</code>(或<code>operator delete[]</code>)的标准库函数释放内存空间。</li>
</ul>
</li>
<li>当自定义了全局的<code>operator new</code>函数和<code>operator delete</code>函数后，我们就担负起了控制动态内存分配的职责。这两个函数<strong>必须是正确的</strong>。因为它们是程序整个处理过程中至关重要的一部分。</li>
<li>标准库定义了<code>operator new</code>函数和<code>operator delete</code>函数的8个重载版本：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些版本可能抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>; <span class="comment">// 分配一个对象</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>);   <span class="comment">// 分配一个数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">// 释放一个对象</span></span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>*) <span class="keyword">noexcept</span>;    <span class="comment">// 释放一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些版本承诺不会抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>, <span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span>, <span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>*, <span class="type">nothrow_t</span>&amp;)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>*, <span class="type">nothrow_t</span>&amp;) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用程序可以自定义上面函数版本中的任意一个，前提是自定义的版本必须位于<strong>全局作用域</strong>或者<strong>类作用域</strong>中。</li>
<li><strong>注意：</strong> 提供新的<code>operator new</code>函数和<code>operator delete</code>函数的目的在于改变内存分配的方式，但是不管怎样，都不能改变<code>new</code>运算符和<code>delete</code>运算符的基本含义。</li>
<li>使用从C语言继承的函数<code>malloc</code>和<code>free</code>函数能实现以某种方式执行分配内存和释放内存的操作：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="type">void</span> *mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">        <span class="keyword">return</span> mme;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">bad_alloc</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *mem)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h3><ul>
<li>应该使用new的定位<code>new(placement new)</code>形式传递一个地址，定位<code>new</code>的形式如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (place_address) type</span><br><span class="line"><span class="built_in">new</span> (place_address) <span class="built_in">type</span> (initializers)</span><br><span class="line"><span class="built_in">new</span> (place_address) type [size]</span><br><span class="line"><span class="built_in">new</span> (place_address) type [size] &#123;braced initializer list&#125;</span><br><span class="line"><span class="comment">// place_address必须是一个指针，同时在initializers中提供一个(可能为空的)以逗号分隔的初始值列表，该初始值列表将用于构造新分配的对象。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当只传入一个指针类型的实参时，定位<code>new</code>表达式构造对象但是不分配内存。</li>
<li>调用析构函数会销毁对象，但是不会释放内存。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;a value&quot;</span>); <span class="comment">// 分配并初始化一个string对象</span></span><br><span class="line">sp-&gt;~<span class="built_in">string</span>();</span><br></pre></td></tr></table></figure>

<h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><ul>
<li>运行时类型识别<code>(run-time type identification, RTTI)</code>的功能由两个运算符实现：<ul>
<li><code>typeid</code>运算符， 用于返回表达式的类型。</li>
<li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换曾派生类的指针或引用。</li>
</ul>
</li>
<li>使用<code>RTTI</code>必须要加倍小心。在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。</li>
</ul>
<h3 id="dynamic-cast运算符"><a href="#dynamic-cast运算符" class="headerlink" title="dynamic_cast运算符"></a>dynamic_cast运算符</h3><ul>
<li>dynamic_cast运算符的使用形式如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)  <span class="comment">// e必须是一个有效的指针</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)  <span class="comment">// e必须是一个左值</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e) <span class="comment">// e不能是左值</span></span><br><span class="line"><span class="comment">// 以上，type类型必须时一个类类型，并且通常情况下该类型应该含有虚函数。</span></span><br><span class="line"><span class="comment">// e的类型必须符合三个条件中的任意一个，它们是：</span></span><br><span class="line"><span class="comment">// 1. e的类型是目标type的公有派生类；</span></span><br><span class="line"><span class="comment">// 2. e的类型是目标type的共有基类；</span></span><br><span class="line"><span class="comment">// 3. e的类型就是目标type的类型；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型的dynamic_cast</span></span><br><span class="line"><span class="comment">// 假设Base类至少含有一个虚函数，Derived是Base的共有派生类。</span></span><br><span class="line"><span class="keyword">if</span> (Derived *dp = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(bp)) &#123;</span><br><span class="line">    <span class="comment">// 使用dp指向的Derived对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="comment">// bp指向一个Base对象</span></span><br><span class="line">    <span class="comment">// 使用dp指向的Base对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用类型的dynamic_cast</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>(<span class="type">const</span> Base &amp;b) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">const</span> Derived &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br><span class="line">        <span class="comment">// 使用b引用的Derived对象</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (bad_cast) &#123;</span><br><span class="line">        <span class="comment">// 处理类型转换失败的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</li>
</ul>
<h3 id="typeid运算符"><a href="#typeid运算符" class="headerlink" title="typeid运算符"></a>typeid运算符</h3><ul>
<li><code>typeid运算符(typeid operator)</code>，它允许程序向表达式提问：<strong>你的对象是什么类型？</strong></li>
<li><code>typeid</code>表达式的形式是<code>typeid(e)</code>，其中<code>e</code>可以是任意表达式或类型的名字，它操作的结果是一个常量对象的引用。它可以作用于任意类型的表达式。</li>
<li>通常情况下，使用typeid比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Derived *dp = <span class="keyword">new</span> Derived;</span><br><span class="line">Base *bp = dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(*dp)) &#123;</span><br><span class="line">    <span class="comment">// bp和dp指向同一类型的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(*bp) == <span class="built_in">typeid</span>(Derived)) &#123;</span><br><span class="line">    <span class="comment">// bp实际指向Derived对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当typeid作用于指针时(而非指针所指向的对象)，返回的结果是该指针的静态编译时类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的检查永远是失败的：bp的类型是指向Base的指针</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">typeid</span>(bp) == <span class="built_in">typeid</span>(Derived)) &#123;</span><br><span class="line">    <span class="comment">// 永远不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用RTTI"><a href="#使用RTTI" class="headerlink" title="使用RTTI"></a>使用RTTI</h3><ul>
<li>用途：为具有继承关系的类实现相等运算符时。对于两个对象来说，如果它们的类型相同并且对应的数据成员取值相同，则说这两个对象是相等的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类的层次关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base&amp;, <span class="type">const</span> Base&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Base的接口成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// Base的数据成员和其他用于实现的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Derived的其他接口成员</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">equal</span><span class="params">(<span class="type">const</span> Base&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// Derived的数据成员和其他用于实现的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型敏感的相等运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Base &amp;lhs, <span class="type">const</span> Base &amp;rhs) &#123;</span><br><span class="line">    <span class="comment">// 如果typeid不相同，返回false；否则虚调用equal</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">typeid</span>(lhs) == <span class="built_in">typeid</span>(rhs) &amp;&amp; lhs.<span class="built_in">equal</span>(rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虚equal函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Derived::equal</span><span class="params">(<span class="type">const</span> Base &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> r = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(rhs);</span><br><span class="line">    <span class="comment">// 执行比较两个Derived对象的操作并返回结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类equal函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Base::equal</span><span class="params">(<span class="type">const</span> Base &amp;rhs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行比较Base对象的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="type-info类"><a href="#type-info类" class="headerlink" title="type_info类"></a>type_info类</h3><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><ul>
<li>枚举类型<code>(enumeration)</code>使我们可以将一组整型常量组织在一起。枚举属于字面值常量类型。</li>
<li><strong>限定作用域的枚举类型(scoped enumeration)</strong>：首先是关键字<code>enum class(或enum struct)</code>，随后是枚举类型名字以及用花括号括起来的以逗号分隔的枚举成员列表，最后是一个分号。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">open_modes</span> &#123;input, output, append&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>不限定作用域的枚举类型<code>(unscoped enumeration)</code>：省略关键字<code>class(或struct)</code>，枚举类型的名字是可选的。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123;red, yellow, green&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;floatPrec = <span class="number">6</span>, doublePrec = <span class="number">10</span>, double_doublePrec = <span class="number">10</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h2><p><strong>成员指针</strong>：指可以指向类的非静态成员的指针。</p>
<h3 id="数据成员指针"><a href="#数据成员指针" class="headerlink" title="数据成员指针"></a>数据成员指针</h3><ul>
<li>和其他指针一样，在声明成员指针时也使用*来表示当前声明的名字是一个指针。与普通指针不同的时，成员指针还必须包含成员所属的类。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pdata可以指向一个常量(非常量)Screen对象的string成员</span></span><br><span class="line"><span class="type">const</span> string Screen::*pdata;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">auto</span> pdata = &amp;Screen::contents;</span><br></pre></td></tr></table></figure>

<ul>
<li>当我们初始化一个成员指针或为成员指针赋值时，该指针没有指向任何数据。成员指针指定了成员而非该成员所属的对象，只有当解引用成员指针时才提供对象的信息。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Screen myScreen, *pScreen = &amp;myScreen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> s = myScreen.*pdata;</span><br><span class="line"></span><br><span class="line">s = pScreen-&gt;*pdata;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><ul>
<li>因为函数调用运算符的优先级较高，所以在声明指向成员函数的指针并使用这些的指针进行函数调用时，括号必不可少：<code>(C::*p)(parms)</code>和<code>(obj.*p)(args)</code>。</li>
</ul>
<h3 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h3><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><ul>
<li>一个类可以定义在另一个类的内部，前者称为嵌套类(nested class)或嵌套类型(nested type)。<strong>嵌套类常用于定义作为实现部分的类</strong>。</li>
<li>嵌套类是一个独立的类，与外层类基本没有什么关系。特别是，外层类的对象和嵌套类的对象是相互独立的。</li>
<li>嵌套类的名字在外层类作用域中是可见的，在外层类作用域之外不可见。</li>
</ul>
<h2 id="union：一种节省空间的类"><a href="#union：一种节省空间的类" class="headerlink" title="union：一种节省空间的类"></a>union：一种节省空间的类</h2><ul>
<li><code>联合(union)</code>是一种特殊的类。一个<code>union</code>可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。<strong>它不能含有引用类型的成员和虚函数</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Token类型的对象只有一个成员，该成员的类型可能是下列类型中的任意一种</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Token</span> &#123;</span><br><span class="line">    <span class="comment">// 默认情况下成员是共有的</span></span><br><span class="line">    <span class="type">char</span> cval;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">double</span> dval;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>匿名union(anonymous union)</code>是一个未命名的<code>union</code>，并且在右花括号和分号之间没有任何声明。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="type">char</span> cval;</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    <span class="type">double</span> dval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接访问它的成员</span></span><br><span class="line">cal = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">ival = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意：</strong> <code>匿名union</code>不能包含受保护的成员或私有成员，也不能定义成员函数。</li>
</ul>
<h2 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h2><ul>
<li><code>局部类(local class)</code>：可以定义在某个函数的内部的类。它的类型只在定义它的作用域内可见。和嵌套类不同，局部类的成员受到严格限制。</li>
<li>局部类的所有成员(包括函数在内)都必须完整定义在类的内部。因此，局部类的作用与嵌套类相比相差很远。</li>
<li><strong>局部类不能使用函数作用域中的变量。</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a, val;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> inti si;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">loc</span> &#123; a = <span class="number">1024</span>, b&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bar是foo的局部类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">        Loc locVal; <span class="comment">// 正确：使用一个局部类型名</span></span><br><span class="line">        <span class="type">int</span> barVal;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fooBar</span><span class="params">(Loc l = a)</span> </span>&#123;    <span class="comment">// 正确：默认实参是Loc::a</span></span><br><span class="line">            barVal = val;   <span class="comment">// 错误：val是foo的局部变量</span></span><br><span class="line">            barVal == ::val;    <span class="comment">// 正确：使用一个全局对象</span></span><br><span class="line">            barVal = si;    <span class="comment">// 正确：使用一个静态局部对象</span></span><br><span class="line">            locVal = b; <span class="comment">// 正确：使用一个枚举成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;；</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="固有的不可移植的特性"><a href="#固有的不可移植的特性" class="headerlink" title="固有的不可移植的特性"></a>固有的不可移植的特性</h2><p>所谓不可移植的特性是指<strong>因机器而异的特性</strong>，当将含有不可移植特性的程序从一台机器转移到另一台机器上时，通常需要重新编写该程序。</p>
<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><ul>
<li>类可以将其(非静态)数据成员定义成<strong>位域(bit-field)</strong>，在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</li>
<li>位域在内存中的布局是与机器相关的。</li>
<li>位域的类型必须是整型或枚举类型。因为带符号位域的行为是由具体实现确定的，通常情况下我们使用无符号类型保存一个位域。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> Bit;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;</span><br><span class="line">    Bit mode: <span class="number">2</span>;</span><br><span class="line">    Bit modified: <span class="number">1</span>;</span><br><span class="line">    Bit prot_owner: <span class="number">3</span>;</span><br><span class="line">    Bit prot_group: <span class="number">3</span>;</span><br><span class="line">    Bit prot_world: <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">modes</span> &#123;READ = <span class="number">01</span>, WRITE = <span class="number">02</span>, EXECUTE = <span class="number">03</span>&#125;;</span><br><span class="line">    <span class="function">File &amp;<span class="title">open</span><span class="params">(modes)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isRead</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWrite</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用位域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">File::write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modified = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">File::close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( modified)</span><br><span class="line">        <span class="comment">// ...保存内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">File &amp;<span class="title">File::open</span><span class="params">(File::modes m)</span> </span>&#123;</span><br><span class="line">    mode |= READ;   <span class="comment">// 按默认方式设置READ</span></span><br><span class="line">    <span class="comment">// 其他处理</span></span><br><span class="line">    <span class="keyword">if</span>(m &amp; WRITE)   <span class="comment">// 如果打开了READ和WRITE</span></span><br><span class="line">        <span class="comment">// 按照读/写方式打开文件</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="volatile限定符"><a href="#volatile限定符" class="headerlink" title="volatile限定符"></a>volatile限定符</h3><ul>
<li>当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为<code>volatile</code>。关键字<code>volatile</code>告诉编译器不应对这样的对象进行优化。</li>
<li><code>const</code>和<code>volatile</code>的一个重要区别是不能使用合成的拷贝&#x2F;移动构造函数及赋值运算符初始化<code>volatile</code>对象或者从<code>volatile</code>对象赋值。</li>
</ul>
<h3 id="链接指示：extern-“C”"><a href="#链接指示：extern-“C”" class="headerlink" title="链接指示：extern “C”"></a>链接指示：extern “C”</h3><ul>
<li><code>C++</code>使用<code>链接指示(linkage directive)</code>指出任意非<code>C++</code>函数所用的语言。</li>
<li>要想把<code>C++</code>代码和其他语言(包括<code>C</code>语言)编写的代码放在一起使用，要求我们必须有权访问该语言的编译器，并且这个编译器与当前的<code>C++</code>编译器是兼容的。</li>
<li><code>C++</code>从C语言继承的标准库函数可以定义为<code>C</code>函数，但并非必须：决定使用<code>C</code>还是<code>C++</code>实现的<code>C</code>标准库，是每个<code>C++</code>实现的事情。</li>
<li>有时需要在C和C++中编译同一个源文件，为了实现这一目的，在编译C++版本的程序时预处理器定义<code>__cplusplus</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/02/C-Primer-5th-19/" data-id="cmbc76op2000rkmq4fn0hh2oh" data-title="C++ Primer 5th 19" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C-Primer-5th-18" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/02/C-Primer-5th-18/" class="article-date">
  <time class="dt-published" datetime="2025-02-02T14:04:17.000Z" itemprop="datePublished">2025-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/C-Primer-5th/">C++ Primer 5th</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/02/C-Primer-5th-18/">C++ Primer 5th 18</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第十八章-用于大型程序的工具"><a href="#第十八章-用于大型程序的工具" class="headerlink" title="第十八章 用于大型程序的工具"></a>第十八章 用于大型程序的工具</h1><p>大规模应用程序的特殊要求包括：</p>
<ul>
<li>在独立开发的子系统之间协同处理错误的能力。</li>
<li>使用各种库进行协同开发的能力。</li>
<li>对比较复杂的应用概念建模的能力。</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p><strong>异常处理</strong>（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并作出相应的处理。</p>
<h3 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h3><p>在C++语言中，我们通过<strong>抛出</strong>（throwing）一条表达式来<strong>引发</strong>（raised）一个异常。异常类型和当前的调用链决定了哪段<strong>处理代码</strong>（handler）将用来处理该异常。</p>
<p>程序的控制权从<code>throw</code>转移到<code>catch</code>模块。</p>
<p><strong>栈展开</strong>：当<code>throw</code>出现在一个<code>try语句块</code>时，检查该<code>try语句块</code>相关的<code>catch</code>字句，若有匹配则处理；若无匹配，则继续检查外层的<code>try</code>匹配的<code>catch</code>。</p>
<p>若一个异常没有被捕获，则它将终止当前的程序。</p>
<p>对象销毁：</p>
<ul>
<li>块退出后，它的局部对象将被销毁。</li>
<li>若异常发生在构造函数中，即使某个对象只构造了一部分，也要确保已构造的成员正确地被销毁。</li>
<li>将资源释放放在类的析构函数中，以保证资源能被正确释放。析构函数本身不会引发异常。</li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p>若无需访问抛出的异常对象，则可以忽略捕获形参的名字。</p>
<p>通常，若<code>catch</code>接受的异常与某个继承体系有关，则最好将该<code>catch</code>的参数定义成引用类型。</p>
<p>搜索<code>catch</code>未必是最佳匹配，而是第一个匹配，因此，越细化的<code>catch</code>越应该放在<code>catch</code>列表前段。</p>
<p>重新抛出：<code>catch</code>代码执行一条<code>throw;</code>将异常传递给另一个<code>catch</code>语句。</p>
<p>捕获所有异常：<code>catch(...)</code></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>处理构造函数初始值异常的唯一方法是将构造函数协程函数<code>try</code>语句块。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::<span class="built_in">Blob</span>(std::initializer_list&lt;T&gt; il) <span class="keyword">try</span>: </span><br><span class="line">    <span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt; &gt;(il)&#123;</span><br><span class="line">        <span class="comment">/*函数体*/</span></span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">const</span> std::bad_alloc &amp;e)&#123; <span class="built_in">handle_out_of_memory</span>(e); &#125;</span><br></pre></td></tr></table></figure>

<h3 id="noexcept异常说明"><a href="#noexcept异常说明" class="headerlink" title="noexcept异常说明"></a>noexcept异常说明</h3><p>使用<code>noexcept</code>说明指定某个函数不会抛出异常。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">recoup</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">//C++11</span></span><br><span class="line"><span class="function">coid <span class="title">recoup</span><span class="params">(<span class="type">int</span>)</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">//老版本</span></span><br></pre></td></tr></table></figure>

<h3 id="异常类层次"><a href="#异常类层次" class="headerlink" title="异常类层次"></a>异常类层次</h3><p>标准exception层次：</p>
<ul>
<li>exception<ul>
<li>bad_cast</li>
<li>bad_alloc</li>
<li>runtime_error<ul>
<li>overflow_error</li>
<li>underflow_error</li>
<li>range_error</li>
</ul>
</li>
<li>logic_error<ul>
<li>domain_error</li>
<li>invalid_argument</li>
<li>out_of_range</li>
<li>length_error</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>自定义异常类：</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">out_of_stock</span>: <span class="keyword">public</span> std::runtime_error &#123;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">out_of_stock</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>:</span></span><br><span class="line"><span class="function">    std::runtime_error(s)&#123;</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>多个库将名字放置在全局命名空间中将引发<strong>命名空间污染</strong>（namespace pollution）。<strong>命名空间</strong>（namespace）分割了全局命名空间，其中每个命名空间是一个作用域。</p>
<h3 id="命名空间定义"><a href="#命名空间定义" class="headerlink" title="命名空间定义"></a>命名空间定义</h3><p>命名空间的定义包含两部分：1.关键字<code>namespace</code>；2.命名空间名称。后面是一系列由花括号括起来的声明和定义。命名空间作用域后面无需分号。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个命名空间都是一个<strong>作用域</strong>。定义在某个命名空间内的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌套作用域中的任何单位访问。位于该命名空间之外的代码必须明确指出所用的名字是属于哪个命名空间的。</p>
<p>命名空间可以是<strong>不连续</strong>的。这点不同于其他作用域，意味着同一命名空间可以在多处出现。</p>
<p><strong>内联命名空间</strong>（C++11）：</p>
<p>无需使用该命名空间的前缀，通过外层命名空间就可以直接访问。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer&#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">namespace</span> FifthEd&#123;</span><br><span class="line">        <span class="comment">// 表示本书第5版代码</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Query_base</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cplusplus_primer::Query_base qb;</span><br></pre></td></tr></table></figure>

<p><strong>未命名的命名空间</strong>：</p>
<p>指关键字<code>namespace</code>后面紧跟花括号的用法。未命名的命名空间中定义的变量拥有静态的声明周期：在第一次使用前创建，直到程序结束才销毁。不能跨越多个文件。</p>
<h3 id="使用命名空间成员"><a href="#使用命名空间成员" class="headerlink" title="使用命名空间成员"></a>使用命名空间成员</h3><p>像<code>namespace_name::member_name</code>这样使用命名空间的成员非常繁琐。</p>
<p><strong>命名空间的别名</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</span><br></pre></td></tr></table></figure>

<p><strong>using声明</strong>（using declaration）：</p>
<p>一条<code>using</code>声明语句一次只引入命名空间的一个成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>using指示</strong>（using directive）：</p>
<p>使得某个特定的命名空间中所有的名字都可见。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="类、命名空间与作用域"><a href="#类、命名空间与作用域" class="headerlink" title="类、命名空间与作用域"></a>类、命名空间与作用域</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">C1</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::C1::f3</span><br></pre></td></tr></table></figure>

<h3 id="重载与命名空间"><a href="#重载与命名空间" class="headerlink" title="重载与命名空间"></a>重载与命名空间</h3><p><code>using</code>声明语句声明的是一个名字，而非特定的函数，也就是包括该函数的所有版本，都被引入到当前作用域中。</p>
<h2 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h2><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><h3 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h3><h3 id="多重继承下的类作用域"><a href="#多重继承下的类作用域" class="headerlink" title="多重继承下的类作用域"></a>多重继承下的类作用域</h3><ul>
<li>当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</li>
</ul>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><ul>
<li>虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象成为<strong>虚基类</strong>。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</li>
<li>虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</li>
</ul>
<h3 id="构造函数与虚继承"><a href="#构造函数与虚继承" class="headerlink" title="构造函数与虚继承"></a>构造函数与虚继承</h3><ul>
<li>h含有虚基类的对象的构造顺序与一般的顺序稍有<strong>区别</strong>：首先使用提供给最底层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序对其进行初始化。</li>
<li>虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/02/C-Primer-5th-18/" data-id="cmbc76op1000okmq462vm710e" data-title="C++ Primer 5th 18" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C-Primer-5th-17" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/02/C-Primer-5th-17/" class="article-date">
  <time class="dt-published" datetime="2025-02-02T14:04:06.000Z" itemprop="datePublished">2025-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/C-Primer-5th/">C++ Primer 5th</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/02/C-Primer-5th-17/">C++ Primer 5th 17</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第十七章-标准库特殊设施"><a href="#第十七章-标准库特殊设施" class="headerlink" title="第十七章 标准库特殊设施"></a>第十七章 标准库特殊设施</h1><h2 id="tuple类型"><a href="#tuple类型" class="headerlink" title="tuple类型"></a>tuple类型</h2><ul>
<li><code>tuple</code>是类似<code>pair</code>的模板，每个成员类型都可以不同，但<code>tuple</code>可以有任意数量的成员。</li>
<li>但每个确定的<code>tuple</code>类型的成员数目是固定的。</li>
<li>我们可以将<code>tuple</code>看做一个“快速而随意”的数据结构。</li>
</ul>
<p><strong>tuple支持的操作</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>tuple&lt;T1, T2, ..., Tn&gt; t;</code></td>
<td><code>t</code>是一个<code>tuple</code>，成员数为<code>n</code>，第<code>i</code>个成员的类型是<code>Ti</code>所有成员都进行值初始化。</td>
</tr>
<tr>
<td><code>tuple&lt;T1, T2, ..., Tn&gt; t(v1, v2, ..., vn);</code></td>
<td>每个成员用对应的初始值<code>vi</code>进行初始化。此构造函数是<code>explicit</code>的。</td>
</tr>
<tr>
<td><code>make_tuple(v1, v2, ..., vn)</code></td>
<td>返回一个用给定初始值初始化的<code>tuple</code>。<code>tuple</code>的类型从初始值的类型<strong>推断</strong>。</td>
</tr>
<tr>
<td><code>t1 == t2</code></td>
<td>当两个<code>tuple</code>具有相同数量的成员且成员对应相等时，两个<code>tuple</code>相等。</td>
</tr>
<tr>
<td><code>t1 relop t2</code></td>
<td><code>tuple</code>的关系运算使用<strong>字典序</strong>。两个<code>tuple</code>必须具有相同数量的成员。</td>
</tr>
<tr>
<td><code>get&lt;i&gt;(t)</code></td>
<td>返回<code>t</code>的第<code>i</code>个数据成员的引用：如果<code>t</code>是一个左值，结果是一个左值引用；否则，结果是一个右值引用。<code>tuple</code>的所有成员都是<code>public</code>的。</td>
</tr>
<tr>
<td><code>tuple_size&lt;tupleType&gt;::value</code></td>
<td>一个类模板，可以通过一个<code>tuple</code>类型来初始化。它有一个名为<code>value</code>的<code>public constexpr static</code>数据成员，类型为<code>size_t</code>，表示给定<code>tuple</code>类型中成员的数量。</td>
</tr>
<tr>
<td><code>tuple_element&lt;i, tupleType&gt;::type</code></td>
<td>一个类模板，可以通过一个整型常量和一个<code>tuple</code>类型来初始化。它有一个名为<code>type</code>的<code>public</code>成员，表示给定<code>tuple</code>类型中指定成员的类型。</td>
</tr>
</tbody></table>
<h3 id="定义和初始化tuple"><a href="#定义和初始化tuple" class="headerlink" title="定义和初始化tuple"></a>定义和初始化tuple</h3><p>定义和初始化示例：</p>
<ul>
<li><code>tuple&lt;size_t, size_t, size_t&gt; threeD;</code></li>
<li><code>tuple&lt;size_t, size_t, size_t&gt; threeD&#123;1,2,3&#125;;</code></li>
<li><code>auto item = make_tuple(&quot;0-999-78345-X&quot;, 3, 2.00)；</code></li>
</ul>
<p>访问tuple成员：</p>
<ul>
<li><code>auto book = get&lt;0&gt;(item);</code></li>
<li><code>get&lt;2&gt;(item) *= 0.8;</code></li>
</ul>
<h3 id="使用tuple返回多个值"><a href="#使用tuple返回多个值" class="headerlink" title="使用tuple返回多个值"></a>使用tuple返回多个值</h3><ul>
<li><code>tuple</code>最常见的用途是从一个函数返回多个值。</li>
</ul>
<h2 id="bitset类型"><a href="#bitset类型" class="headerlink" title="bitset类型"></a>bitset类型</h2><ul>
<li>处理二进制位的有序集；</li>
<li><code>bitset</code>也是类模板，但尖括号中输入的是<code>bitset</code>的长度而不是元素类型，因为元素类型是固定的，都是一个二进制位。</li>
</ul>
<p>初始化<code>bitset</code>的方法：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>bitset&lt;n&gt; b;</code></td>
<td><code>b</code>有<code>n</code>位；每一位均是0.此构造函数是一个<code>constexpr</code>。</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(u);</code></td>
<td><code>b</code>是<code>unsigned long long</code>值<code>u</code>的低<code>n</code>位的拷贝。如果<code>n</code>大于<code>unsigned long long</code>的大小，则<code>b</code>中超出<code>unsigned long long</code>的高位被置为0。此构造函数是一个<code>constexpr</code>。</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(s, pos, m, zero, one);</code></td>
<td><code>b</code>是<code>string s</code>从位置<code>pos</code>开始<code>m</code>个字符的拷贝。<code>s</code>只能包含字符<code>zero</code>或<code>one</code>：如果<code>s</code>包含任何其他字符，构造函数会抛出<code>invalid_argument</code>异常。字符在<code>b</code>中分别保存为<code>zero</code>和<code>one</code>。<code>pos</code>默认为0，<code>m</code>默认为<code>string::npos</code>，<code>zero</code>默认为’0’，<code>one</code>默认为’1’。</td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(cp, pos, m, zero, one);</code></td>
<td>和上一个构造函数相同，但从<code>cp</code>指向的字符数组中拷贝字符。如果未提供<code>m</code>，则<code>cp</code>必须指向一个<code>C</code>风格字符串。如果提供了<code>m</code>，则从<code>cp</code>开始必须至少有<code>m</code>个<code>zero</code>或<code>one</code>字符。</td>
</tr>
</tbody></table>
<p>初始化案例；</p>
<ul>
<li><code>bitset&lt;13&gt; bitvec1(0xbeef);</code></li>
<li><code>bitset&lt;32&gt; bitvec4(&quot;1100&quot;);</code></li>
</ul>
<p><code>bitset</code>操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>b.any()</code></td>
<td><code>b</code>中是否存在1。</td>
</tr>
<tr>
<td><code>b.all()</code></td>
<td><code>b</code>中都是1。</td>
</tr>
<tr>
<td><code>b.none()</code></td>
<td><code>b</code>中是否没有1。</td>
</tr>
<tr>
<td><code>b.count()</code></td>
<td><code>b</code>中1的个数。</td>
</tr>
<tr>
<td><code>b.size()</code></td>
<td></td>
</tr>
<tr>
<td><code>b.test(pos)</code></td>
<td><code>pos</code>下标是否是1</td>
</tr>
<tr>
<td><code>b.set(pos)</code></td>
<td><code>pos</code>置1</td>
</tr>
<tr>
<td><code>b.set()</code></td>
<td>所有都置1</td>
</tr>
<tr>
<td><code>b.reset(pos)</code></td>
<td>将位置<code>pos</code>处的位复位</td>
</tr>
<tr>
<td><code>b.reset()</code></td>
<td>将<code>b</code>中所有位复位</td>
</tr>
<tr>
<td><code>b.flip(pos)</code></td>
<td>将位置<code>pos</code>处的位取反</td>
</tr>
<tr>
<td><code>b.flip()</code></td>
<td>将<code>b</code>中所有位取反</td>
</tr>
<tr>
<td><code>b[pos]</code></td>
<td>访问<code>b</code>中位置<code>pos</code>处的位；如果<code>b</code>是<code>const</code>的，则当该位置位时，返回<code>true</code>；否则返回<code>false</code>。</td>
</tr>
<tr>
<td><code>b.to_ulong()</code></td>
<td>返回一个<code>unsigned long</code>值，其位模式和<code>b</code>相同。如果<code>b</code>中位模式不能放入指定的结果类型，则抛出一个<code>overflow_error</code>异常。</td>
</tr>
<tr>
<td><code>b.to_ullong()</code></td>
<td>类似上面，返回一个<code>unsigned long long</code>值。</td>
</tr>
<tr>
<td><code>b.to_string(zero, one)</code></td>
<td>返回一个<code>string</code>，表示<code>b</code>中位模式。<code>zero</code>和<code>one</code>默认为0和1。</td>
</tr>
<tr>
<td><code>os &lt;&lt; b</code></td>
<td>将<code>b</code>中二进制位打印为字符<code>1</code>或<code>0</code>，打印到流<code>os</code>。</td>
</tr>
<tr>
<td><code>is &gt;&gt; b</code></td>
<td>从<code>is</code>读取字符存入<code>b</code>。当下一个字符不是1或0时，或是已经读入<code>b.size()</code>个位时，读取过程停止。</td>
</tr>
</tbody></table>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><ul>
<li>正则表达式（reqular expression）是一种描述字符序列的方法，是一种很强大的工具。</li>
</ul>
<p>正则表达式库组件：</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>regex</code></td>
<td>表示一个正则表达式的类</td>
</tr>
<tr>
<td><code>regex_match</code></td>
<td>将一个字符序列与一个正则表达式匹配</td>
</tr>
<tr>
<td><code>regex_search</code></td>
<td>寻找第一个与正则表达式匹配的子序列</td>
</tr>
<tr>
<td><code>regex_replace</code></td>
<td>使用给定格式替换一个正则表达式</td>
</tr>
<tr>
<td><code>sregex_iterator</code></td>
<td>迭代器适配器，调用<code>regex_searcg</code>来遍历一个<code>string</code>中所有匹配的子串</td>
</tr>
<tr>
<td><code>smatch</code></td>
<td>容器类，保存在<code>string</code>中搜索的结果</td>
</tr>
<tr>
<td><code>ssub_match</code></td>
<td><code>string</code>中匹配的子表达式的结果</td>
</tr>
</tbody></table>
<p><code>regex_match</code>和<code>regex_search</code>的参数：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>(seq, m, r, mft)</code></td>
<td>在字符序列<code>seq</code>中查找<code>regex</code>对象<code>r</code>中的正则表达式。<code>seq</code>可以是一个<code>string</code>、标识范围的一对迭代器、一个指向空字符结尾的字符数组的指针。</td>
</tr>
<tr>
<td><code>(seq, r, mft)</code></td>
<td><code>m</code>是一个<code>match</code>对象，用来保存匹配结果的相关细节。<code>m</code>和<code>seq</code>必须具有兼容的类型。<code>mft</code>是一个可选的<code>regex_constants::match_flag_type</code>值。</td>
</tr>
</tbody></table>
<ul>
<li>这些操作会返回<code>bool</code>值，指出是否找到匹配。</li>
</ul>
<h3 id="使用正则表达式库"><a href="#使用正则表达式库" class="headerlink" title="使用正则表达式库"></a>使用正则表达式库</h3><ul>
<li><code>regex</code>使用的正则表达式语言是<code>ECMAScript</code>，模式<code>[[::alpha::]]</code>匹配任意字母。</li>
<li>由于反斜线是C++中的特殊字符，在模式中每次出现<code>\</code>的地方，必须用一个额外的反斜线<code>\\</code>告知C++我们需要一个反斜线字符。</li>
<li>简单案例：<ul>
<li><code>string pattern(&quot;[^c]ei&quot;); pattern = &quot;[[:alpha:]]*&quot; + pattern + &quot;[[:alpha:]]*&quot;</code> 查找不在字符c之后的字符串ei</li>
<li><code>regex r(pattern);</code> 构造一个用于查找模式的regex</li>
<li><code>smatch results;</code> 定义一个对象保存搜索结果</li>
<li><code>string test_str = &quot;receipt freind theif receive&quot;;</code></li>
<li><code>if (regex_search(test_str, results, r)) cout &lt;&lt; results.str() &lt;&lt; endl;</code> 如有匹配子串，打印匹配的单词。</li>
</ul>
</li>
</ul>
<p><code>regex</code>（和<code>wregex</code>）选项：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>regex r(re)</code> <code>regex r(re, f)</code></td>
<td><code>re</code>表示一个正则表达式，它可以是一个<code>string</code>、一对表示字符范围的迭代器、一个指向空字符结尾的字符数组的指针、一个字符指针和一个计数器、一个花括号包围的字符列表。<code>f</code>是指出对象如何处理的标志。<code>f</code>通过下面列出来的值来设置。如果未指定<code>f</code>，其默认值为<code>ECMAScript</code>。</td>
</tr>
<tr>
<td><code>r1 = re</code></td>
<td>将<code>r1</code>中的正则表达式替换Wie<code>re</code>。<code>re</code>表示一个正则表达式，它可以是另一个<code>regex</code>对象、一个<code>string</code>、一个指向空字符结尾的字符数组的指针或是一个花括号包围的字符列表。</td>
</tr>
<tr>
<td><code>r1.assign(re, f)</code></td>
<td>和使用赋值运算符（&#x3D;）的效果相同：可选的标志<code>f</code>也和<code>regex</code>的构造函数中对应的参数含义相同。</td>
</tr>
<tr>
<td><code>r.mark_count()</code></td>
<td><code>r</code>中子表达式的数目</td>
</tr>
<tr>
<td><code>r.flags()</code></td>
<td>返回<code>r</code>的标志集</td>
</tr>
</tbody></table>
<p>定义<code>regex</code>时指定的标志：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>icase</code></td>
<td>在匹配过程中忽略大小写</td>
</tr>
<tr>
<td><code>nosubs</code></td>
<td>不保存匹配的子表达式</td>
</tr>
<tr>
<td><code>optimize</code></td>
<td>执行速度优先于构造速度</td>
</tr>
<tr>
<td><code>ECMAScript</code></td>
<td>使用<code>ECMA-262</code>指定的语法</td>
</tr>
<tr>
<td><code>basic</code></td>
<td>使用<code>POSIX</code>基本的正则表达式语法</td>
</tr>
<tr>
<td><code>extended</code></td>
<td>使用<code>POSIX</code>扩展的正则表达式语法</td>
</tr>
<tr>
<td><code>awk</code></td>
<td>使用<code>POSIX</code>版本的<code>awk</code>语言的语法</td>
</tr>
<tr>
<td><code>grep</code></td>
<td>使用<code>POSIX</code>版本的<code>grep</code>的语法</td>
</tr>
<tr>
<td><code>egrep</code></td>
<td>使用<code>POSIX</code>版本的<code>egrep</code>的语法</td>
</tr>
</tbody></table>
<ul>
<li>可以将正则表达式本身看做是一种简单程序语言设计的程序。在运行时，当一个<code>regex</code>对象被初始化或被赋予新模式时，才被“编译”。</li>
<li>如果编写的正则表达式存在错误，会在运行时抛出一个<code>regex_error</code>的异常。</li>
<li>避免创建不必要的正则表达式。构建一个<code>regex</code>对象可能比较耗时。</li>
</ul>
<h3 id="匹配与regex迭代器类型"><a href="#匹配与regex迭代器类型" class="headerlink" title="匹配与regex迭代器类型"></a>匹配与regex迭代器类型</h3><p><code>sregex_iterator</code>操作（用来获得所有匹配）：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>sregex_iterator it(b, e, r);</code></td>
<td>一个<code>sregex_iterator</code>，遍历迭代器<code>b</code>和<code>e</code>表示的<code>string</code>。它调用<code>sregex_search(b, e, r)</code>将<code>it</code>定位到输入中第一个匹配的位置。</td>
</tr>
<tr>
<td><code>sregex_iterator end;</code></td>
<td><code>sregex_iterator</code>的尾后迭代器</td>
</tr>
<tr>
<td><code>*it</code>， <code>it-&gt;</code></td>
<td>根据最后一个调用<code>regex_search</code>的结果，返回一个<code>smatch</code>对象的引用或一个指向<code>smatch</code>对象的指针。</td>
</tr>
<tr>
<td><code>++it</code> ， <code>it++</code></td>
<td>从输入序列当前匹配位置开始调用<code>regex_search</code>。前置版本返回递增后迭代器；后置版本返回旧值。</td>
</tr>
<tr>
<td><code>it1 == it2</code></td>
<td>如果两个<code>sregex_iterator</code>都是尾后迭代器，则它们相等。两个非尾后迭代器是从相同的输入序列和<code>regex</code>对象构造，则它们相等。</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串file中所有匹配模式r的子串输出</span></span><br><span class="line"><span class="keyword">for</span> (sregex_iterator <span class="built_in">it</span>(file.<span class="built_in">begin</span>(), file.<span class="built_in">end</span>(), r), end_it; it != end_it; ++it)&#123;</span><br><span class="line">    cout &lt;&lt; it -&gt;<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>smatch</code>操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>m.ready()</code></td>
<td>如果已经通过调用<code>regex_search</code>或<code>regex_match</code>设置了<code>m</code>，则返回<code>true</code>；否则返回<code>false</code>。如果<code>ready</code>返回<code>false</code>，则对<code>m</code>进行操作是未定义的。</td>
</tr>
<tr>
<td><code>m.size()</code></td>
<td>如果匹配失败，则返回0，；否则返回最近一次匹配的正则表达式中子表达式的数目。</td>
</tr>
<tr>
<td><code>m.empty()</code></td>
<td>等价于<code>m.size() == 0</code></td>
</tr>
<tr>
<td><code>m.prefix()</code></td>
<td>一个<code>ssub_match</code>对象，标识当前匹配之前的序列</td>
</tr>
<tr>
<td><code>m.suffix()</code></td>
<td>一个<code>ssub_match</code>对象，标识当前匹配之后的部分</td>
</tr>
<tr>
<td><code>m.format(...)</code></td>
<td></td>
</tr>
<tr>
<td><code>m.length(n)</code></td>
<td>第<code>n</code>个匹配的子表达式的大小</td>
</tr>
<tr>
<td><code>m.position(n)</code></td>
<td>第<code>n</code>个子表达式距离序列开始的长度</td>
</tr>
<tr>
<td><code>m.str(n)</code></td>
<td>第<code>n</code>个子表达式匹配的<code>string</code></td>
</tr>
<tr>
<td><code>m[n]</code></td>
<td>对应第<code>n</code>个子表达式的<code>ssub_match</code>对象</td>
</tr>
<tr>
<td><code>m.begin(), m.end()</code></td>
<td>表示<code>m</code>中<code>ssub_match</code>元素范围的迭代器。</td>
</tr>
<tr>
<td><code>m.cbegin(), m.cend()</code></td>
<td>常量迭代器</td>
</tr>
</tbody></table>
<h3 id="使用子表达式"><a href="#使用子表达式" class="headerlink" title="使用子表达式"></a>使用子表达式</h3><ul>
<li>正则表达式语法通常用括号表示子表达式。</li>
<li>子表达式的索引从1开始。</li>
<li>在<code>fmt</code>中用<code>$</code>后跟子表达式的索引号来标识一个特定的子表达式。</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">regex_search</span>(filename, results, r))</span><br><span class="line">    cout &lt;&lt; results.<span class="built_in">str</span>(<span class="number">1</span>) &lt;&lt; endl;  <span class="comment">// .str(1)获取第一个子表达式匹配结果</span></span><br></pre></td></tr></table></figure>

<p><code>ssub_match</code>子匹配操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>matched</code></td>
<td>一个<code>public bool</code>数据成员，指出<code>ssub_match</code>是否匹配了</td>
</tr>
<tr>
<td><code>first</code>， <code>second</code></td>
<td><code>public</code>数据成员，指向匹配序列首元素和尾后位置的迭代器。如果未匹配，则<code>first</code>和<code>second</code>是相等的。</td>
</tr>
<tr>
<td><code>length()</code></td>
<td>匹配的大小，如果<code>matched</code>为<code>false</code>，则返回0。</td>
</tr>
<tr>
<td><code>str()</code></td>
<td>返回一个包含输入中匹配部分的<code>string</code>。如果<code>matched</code>为<code>false</code>，则返回空<code>string</code>。</td>
</tr>
<tr>
<td><code>s = ssub</code></td>
<td>将<code>ssub_match</code>对象<code>ssub</code>转化为<code>string</code>对象<code>s</code>。等价于<code>s=ssub.str()</code>，转换运算符不是<code>explicit</code>的。</td>
</tr>
</tbody></table>
<h3 id="使用regex-replace"><a href="#使用regex-replace" class="headerlink" title="使用regex_replace"></a>使用regex_replace</h3><p>正则表达式替换操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>m.format(dest, fmt, mft)</code>, <code>m.format(fmt, mft)</code></td>
<td>使用格式字符串<code>fmt</code>生成格式化输出，匹配在<code>m</code>中，可选的<code>match_flag_type</code>标志在<code>mft</code>中。第一个版本写入迭代器<code>dest</code>指向的目的为止，并接受<code>fmt</code>参数，可以是一个<code>string</code>，也可以是一个指向空字符结尾的字符数组的指针。<code>mft</code>的默认值是<code>format_default</code>。</td>
</tr>
<tr>
<td><code>rege_replace(dest, seq, r, fmt, mft)</code>，  <code>regex_replace(seq, r, fmt, mft)</code></td>
<td>遍历<code>seq</code>，用<code>regex_search</code>查找与<code>regex</code>对象<code>r</code>相匹配的子串，使用格式字符串<code>fmt</code>和可选的<code>match_flag_type</code>标志来生成输出。<code>mft</code>的默认值是<code>match_default</code></td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string phone = <span class="string">&quot;(\\()?(\\d&#123;3&#125;)(\\))?([-. ])?(\\d&#123;3&#125;)([-. ]?)(\\d&#123;4&#125;)&quot;</span></span><br><span class="line">string fmt = <span class="string">&quot;$2.$5.$7&quot;</span>;  <span class="comment">// 将号码格式改为ddd.ddd.dddd</span></span><br><span class="line"><span class="function">regex <span class="title">r</span><span class="params">(phone)</span></span>;  <span class="comment">// 用来寻找模式的regex对象</span></span><br><span class="line">string number = <span class="string">&quot;(908) 555-1800&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">regex_replace</span>(number, r, fmt) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>匹配标志：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>match_default</code></td>
<td>等价于<code>format_default</code></td>
</tr>
<tr>
<td><code>match_not_bol</code></td>
<td>不将首字符作为行首处理</td>
</tr>
<tr>
<td><code>match_not_eol</code></td>
<td>不将尾字符作为行尾处理</td>
</tr>
<tr>
<td><code>match_not_bow</code></td>
<td>不将首字符作为单词首处理</td>
</tr>
<tr>
<td><code>match_not_eow</code></td>
<td>不将尾字符作为单词尾处理</td>
</tr>
<tr>
<td><code>match_any</code></td>
<td>如果存在多于一个匹配，则可以返回任意一个匹配</td>
</tr>
<tr>
<td><code>match_not_null</code></td>
<td>不匹配任何空序列</td>
</tr>
<tr>
<td><code>match_continuous</code></td>
<td>匹配必须从输入的首字符开始</td>
</tr>
<tr>
<td><code>match_prev_avail</code></td>
<td>输入序列包含第一个匹配之前的内容</td>
</tr>
<tr>
<td><code>format_default</code></td>
<td>用<code>ECMAScript</code>规则替换字符串</td>
</tr>
<tr>
<td><code>format_sed</code></td>
<td>用<code>POSIX sed</code>规则替换字符串</td>
</tr>
<tr>
<td><code>format_no_copy</code></td>
<td>不输出输入序列中未匹配的部分</td>
</tr>
<tr>
<td><code>format_first_only</code></td>
<td>只替换子表达式的第一次出现</td>
</tr>
</tbody></table>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><ul>
<li>新标准之前，C和C++都依赖一个简单的C库函数<code>rand</code>来生成随机数，且只符合均匀分布。</li>
<li>新标准：<strong>随机数引擎</strong> + <strong>随机数分布类</strong>， 定义在   <code>random</code>头文件中。</li>
<li>C++程序应该使用<code>default_random_engine</code>类和恰当的分布类对象。</li>
</ul>
<h3 id="随机数引擎和分布"><a href="#随机数引擎和分布" class="headerlink" title="随机数引擎和分布"></a>随机数引擎和分布</h3><p>随机数引擎操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>Engine e;</code></td>
<td>默认构造函数；使用该引擎类型默认的种子</td>
</tr>
<tr>
<td><code>Engine e(s);</code></td>
<td>使用整型值<code>s</code>作为种子</td>
</tr>
<tr>
<td><code>e.seed(s)</code></td>
<td>使用种子<code>s</code>重置引擎的状态</td>
</tr>
<tr>
<td><code>e.min()</code>，<code>e.max()</code></td>
<td>此引擎可生成的最小值和最大值</td>
</tr>
<tr>
<td><code>Engine::result_type</code></td>
<td>此引擎生成的<code>unsigned</code>整型类型</td>
</tr>
<tr>
<td><code>e.discard(u)</code></td>
<td>将引擎推进<code>u</code>步；<code>u</code>的类型为<code>unsigned long long</code></td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化分布类型</span></span><br><span class="line"><span class="function">uniform_int_distribution&lt;<span class="type">unsigned</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line"><span class="comment">// 初始化引擎</span></span><br><span class="line">default_random_engine e;</span><br><span class="line"><span class="comment">// 随机生成0-9的无符号整数</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">u</span>(e) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>设置随机数发生器种子</strong>：</p>
<ul>
<li>种子就是一个数值，引擎可以利用它从序列中一个新位置重新开始生成随机数。</li>
<li>种子可以使用系统函数<code>time(0)</code>。</li>
</ul>
<h3 id="其他随机数分布"><a href="#其他随机数分布" class="headerlink" title="其他随机数分布"></a>其他随机数分布</h3><p>分布类型的操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>Dist d;</code></td>
<td>默认够赞函数；使<code>d</code>准备好被使用。其他构造函数依赖于<code>Dist</code>的类型；分布类型的构造函数是<code>explicit</code>的。</td>
</tr>
<tr>
<td><code>d(e)</code></td>
<td>用相同的<code>e</code>连续调用<code>d</code>的话，会根据<code>d</code>的分布式类型生成一个随机数序列；<code>e</code>是一个随机数引擎对象。</td>
</tr>
<tr>
<td><code>d.min()</code>,<code>d.max()</code></td>
<td>返回<code>d(e)</code>能生成的最小值和最大值。</td>
</tr>
<tr>
<td><code>d.reset()</code></td>
<td>重建<code>d</code>的状态，是的随后对<code>d</code>的使用不依赖于<code>d</code>已经生成的值。</td>
</tr>
</tbody></table>
<h2 id="IO库再探"><a href="#IO库再探" class="headerlink" title="IO库再探"></a>IO库再探</h2><h3 id="格式化输入与输出"><a href="#格式化输入与输出" class="headerlink" title="格式化输入与输出"></a>格式化输入与输出</h3><ul>
<li>使用操纵符改变格式状态。</li>
<li>控制布尔值的格式： <code>cout &lt;&lt; boolalpha &lt;&lt; true &lt;&lt; endl;</code></li>
<li>指定整型的进制：<code>cout &lt;&lt; dec &lt;&lt; 20 &lt;&lt; endl;</code></li>
</ul>
<p>定义在<code>iostream</code>中的操纵符：</p>
<table>
<thead>
<tr>
<th>操纵符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>boolalpha</code></td>
<td>将<code>true</code>和<code>false</code>输出为字符串</td>
</tr>
<tr>
<td><code>* noboolalpha</code></td>
<td>将<code>true</code>和<code>false</code>输出为1,0</td>
</tr>
<tr>
<td><code>showbase</code></td>
<td>对整型值输出表示进制的前缀</td>
</tr>
<tr>
<td><code>* noshowbase</code></td>
<td>不生成表示进制的前缀</td>
</tr>
<tr>
<td><code>showpoint</code></td>
<td>对浮点值总是显示小数点</td>
</tr>
<tr>
<td><code>* noshowpoint</code></td>
<td>只有当浮点值包含小数部分时才显示小数点</td>
</tr>
<tr>
<td><code>showpos</code></td>
<td>对非负数显示<code>+</code></td>
</tr>
<tr>
<td><code>* noshowpos</code></td>
<td>对非负数不显示<code>+</code></td>
</tr>
<tr>
<td><code>uppercase</code></td>
<td>在十六进制中打印<code>0X</code>，在科学计数法中打印<code>E</code></td>
</tr>
<tr>
<td><code>* nouppercase</code></td>
<td>在十六进制中打印<code>0x</code>，在科学计数法中打印<code>e</code></td>
</tr>
<tr>
<td><code>* dec</code></td>
<td>整型值显示为十进制</td>
</tr>
<tr>
<td><code>hex</code></td>
<td>整型值显示为十六进制</td>
</tr>
<tr>
<td><code>oct</code></td>
<td>整型值显示为八进制</td>
</tr>
<tr>
<td><code>left</code></td>
<td>在值的右侧添加填充字符</td>
</tr>
<tr>
<td><code>right</code></td>
<td>在值的左侧添加填充字符</td>
</tr>
<tr>
<td><code>internal</code></td>
<td>在符号和值之间添加填充字符</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>浮点值显示为定点十进制</td>
</tr>
<tr>
<td><code>scientific</code></td>
<td>浮点值显示为科学计数法</td>
</tr>
<tr>
<td><code>hexfloat</code></td>
<td>浮点值显示为十六进制（C++11）</td>
</tr>
<tr>
<td><code>defaultfloat</code></td>
<td>充值浮点数格式为十进制（C++11）</td>
</tr>
<tr>
<td><code>unitbuf</code></td>
<td>每次输出操作后都刷新缓冲区</td>
</tr>
<tr>
<td>1</td>
<td><code>* nounitbuf</code></td>
</tr>
<tr>
<td><code>* skipws</code></td>
<td>输入运算符跳过空白符</td>
</tr>
<tr>
<td><code>noskipws</code></td>
<td>输入运算符不跳过空白符</td>
</tr>
<tr>
<td><code>flush</code></td>
<td>刷新<code>ostream</code>缓冲区</td>
</tr>
<tr>
<td><code>ends</code></td>
<td>插入空字符，然后刷新<code>ostream</code>缓冲区</td>
</tr>
<tr>
<td><code>endl</code></td>
<td>插入换行，然后刷新<code>ostream</code>缓冲区</td>
</tr>
</tbody></table>
<p>其中<code>*</code>表示默认的流状态。</p>
<h3 id="未格式化的输入-输出操作"><a href="#未格式化的输入-输出操作" class="headerlink" title="未格式化的输入&#x2F;输出操作"></a>未格式化的输入&#x2F;输出操作</h3><p>单字节低层IO操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>is.get(ch)</code></td>
<td>从<code>istream is</code>读取下一个字节存入字符<code>cn</code>中。返回<code>is</code>。</td>
</tr>
<tr>
<td><code>os.put(ch)</code></td>
<td>将字符<code>ch</code>输出到<code>ostream os</code>。返回<code>os</code>。</td>
</tr>
<tr>
<td><code>is.get()</code></td>
<td>将<code>is</code>的下一个字节作为<code>int</code>返回</td>
</tr>
<tr>
<td><code>is.putback(ch)</code></td>
<td>将字符<code>ch</code>放回<code>is</code>。返回<code>is</code>。</td>
</tr>
<tr>
<td><code>is.unget()</code></td>
<td>将<code>is</code>向后移动一个字节。返回<code>is</code>。</td>
</tr>
<tr>
<td><code>is.peek()</code></td>
<td>将下一个字节作为<code>int</code>返回，但不从流中删除它。</td>
</tr>
</tbody></table>
<p>多字节低层IO操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>is.get(sink, size, delim)</code></td>
<td>从<code>is</code>中读取最多<code>size</code>个字节，并保存在字符数组中，字符数组的起始地址由<code>sink</code>给出。读取过程直到遇到字符<code>delim</code>或读取了<code>size</code>个字节或遇到文件尾时停止。如果遇到了<code>delim</code>，则将其留在输入流中，不读取出来存入<code>sink</code>。</td>
</tr>
<tr>
<td><code>is.getline(sink, size, delim)</code></td>
<td>与接收三个参数的<code>get</code>版本类似，但会读取并丢弃<code>delim</code>。</td>
</tr>
<tr>
<td><code>is.read(sink, size)</code></td>
<td>读取最多<code>size</code>个字节，存入字符数组<code>sink</code>中。返回<code>is</code>。</td>
</tr>
<tr>
<td><code>is.gcount()</code></td>
<td>返回上一个未格式化读取从<code>is</code>读取的字节数</td>
</tr>
<tr>
<td><code>os.write(source, size)</code></td>
<td>将字符数组<code>source</code>中的<code>size</code>个字节写入<code>os</code>。返回<code>os</code>。</td>
</tr>
<tr>
<td><code>is.ignore(size, delim)</code></td>
<td>读取并忽略最多<code>size</code>个字符，包括<code>delim</code>。与其他未格式化函数不同，<code>ignore</code>有默认参数：<code>size</code>默认值是1，<code>delim</code>的默认值为文件尾。</td>
</tr>
</tbody></table>
<ul>
<li>注意：一般情况下，主张使用标准库提供的高层抽象，低层函数容易出错。</li>
</ul>
<h3 id="流随机访问"><a href="#流随机访问" class="headerlink" title="流随机访问"></a>流随机访问</h3><ul>
<li>只适用于<code>fstream</code>和<code>sstream</code>。</li>
<li>通过将标记<code>seek</code>到一个给定位置来重定位它。</li>
<li><code>tell</code>告诉我们标记的当前位置。</li>
</ul>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>tellg()</code>，<code>tellp</code></td>
<td>返回一个输入流中（<code>tellg</code>）或输出流中（<code>tellp</code>）标记的当前位置。</td>
</tr>
<tr>
<td><code>seekg(pos)</code>，<code>seekp(pos)</code></td>
<td>在一个输入流或输出流中将标记重定位到给定的绝对地址。<code>pos</code>通常是一个当前<code>teelg</code>或<code>tellp</code>返回的值。</td>
</tr>
<tr>
<td><code>seekp(off, from)</code>，<code>seekg(off, from)</code></td>
<td>在一个输入流或输出流中将标记定位到<code>from</code>之前或之后<code>off</code>个字符，<code>from</code>可以是下列值之一：<code>beg</code>，偏移量相对于流开始位置；<code>cur</code>，偏移量相对于流当前位置；<code>end</code>，偏移量相对于流结尾位置。</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/02/C-Primer-5th-17/" data-id="cmbc76op1000lkmq4bm56ebpi" data-title="C++ Primer 5th 17" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C-Primer-5th-16" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/02/C-Primer-5th-16/" class="article-date">
  <time class="dt-published" datetime="2025-02-02T14:03:44.000Z" itemprop="datePublished">2025-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/C-Primer-5th/">C++ Primer 5th</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/02/C-Primer-5th-16/">C++ Primer 5th 16</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第十六章-模板和泛型编程"><a href="#第十六章-模板和泛型编程" class="headerlink" title="第十六章 模板和泛型编程"></a>第十六章 模板和泛型编程</h1><ul>
<li>面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。<ul>
<li>OOP能处理类型在程序运行之前都未知的情况；</li>
<li>泛型编程中，在编译时就可以获知类型。</li>
</ul>
</li>
</ul>
<h2 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h2><ul>
<li><strong>模板</strong>：模板是泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。</li>
</ul>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><ul>
<li><code>template &lt;typename T&gt; int compare(const T &amp;v1, const T &amp;v2)&#123;&#125;</code></li>
<li>模板定义以关键字 <code>template</code>开始，后接<strong>模板形参表</strong>，模板形参表是用<strong>尖括号</strong><code>&lt;&gt;</code>括住的一个或多个<strong>模板形参</strong>的列表，用逗号分隔，<strong>不能为空</strong>。</li>
<li>使用模板时，我们显式或隐式地指定模板实参，将其绑定到模板参数上。</li>
<li>模板类型参数：类型参数前必须使用关键字<code>class</code>或者<code>typename</code>，这两个关键字含义相同，可以互换使用。旧的程序只能使用<code>class</code>。</li>
<li>非类型模板参数：表示一个值而非一个类型。实参必须是常量表达式。<code>template &lt;class T, size_t N&gt; void array_init(T (&amp;parm)[N])&#123;&#125;</code></li>
<li>内联函数模板： <code>template &lt;typename T&gt; inline T min(const T&amp;, const T&amp;);</code></li>
<li>模板程序应该尽量减少对实参类型的要求。</li>
<li>函数模板和类模板成员函数的定义通常放在头文件中。</li>
</ul>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><ul>
<li>类模板用于生成类的蓝图。</li>
<li>不同于函数模板，编译器不能推断模板参数类型。</li>
<li><strong>定义类模板</strong>：<ul>
<li><code>template &lt;class Type&gt; class Queue &#123;&#125;;</code></li>
</ul>
</li>
<li>实例化类模板：提供显式模板实参列表，来实例化出特定的类。</li>
<li>一个类模板中所有的实例都形成一个独立的类。</li>
<li><strong>模板形参作用域</strong>：模板形参的名字可以在声明为模板形参之后直到模板声明或定义的末尾处使用。</li>
<li>类模板的成员函数：<ul>
<li><code>template &lt;typename T&gt; ret-type Blob::member-name(parm-list)</code></li>
</ul>
</li>
<li>默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</li>
<li>新标准允许模板将自己的类型参数成为友元。<code>template &lt;typename T&gt; class Bar&#123;friend T;&#125;;</code>。</li>
<li>模板类型别名：因为模板不是一个类型，因此无法定义一个<code>typedef</code>引用一个模板，但是新标准允许我们为类模板定义一个类型别名：<code>template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;</code></li>
</ul>
<h3 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h3><ul>
<li>模板参数与作用域：一个模板参数名的可用范围是在声明之后，至模板声明或定义结束前。</li>
<li>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置。</li>
<li>当我们希望通知编译器一个名字表示类型时，必须使用关键字<code>typename</code>，而不能使用<code>class</code>。</li>
<li>默认模板实参：<code>template &lt;class T = int&gt; class Numbers&#123;&#125;</code></li>
</ul>
<h3 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h3><ul>
<li>成员模板（member template）：本身是模板的函数成员。<ul>
<li>普通（非模板）类的成员模板。</li>
<li>类模板的成员模板。</li>
</ul>
</li>
</ul>
<h3 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h3><ul>
<li>动机：在多个文件中实例化相同模板的额外开销可能非常严重。</li>
<li>显式实例化：<ul>
<li><code>extern template declaration;  // 实例化声明</code></li>
<li><code>template declaration;  // 实例化定义</code></li>
</ul>
</li>
</ul>
<h3 id="效率与灵活性"><a href="#效率与灵活性" class="headerlink" title="效率与灵活性"></a>效率与灵活性</h3><h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><ul>
<li>对函数模板，编译器利用调用中的函数实参来确定其模板参数，这个过程叫<strong>模板实参推断</strong>。</li>
</ul>
<h3 id="类型转换与模板类型参数"><a href="#类型转换与模板类型参数" class="headerlink" title="类型转换与模板类型参数"></a>类型转换与模板类型参数</h3><ul>
<li>能够自动转换类型的只有：<ul>
<li>和其他函数一样，顶层<code>const</code>会被忽略。</li>
<li>数组实参或函数实参转换为指针。</li>
</ul>
</li>
</ul>
<h3 id="函数模板显式实参"><a href="#函数模板显式实参" class="headerlink" title="函数模板显式实参"></a>函数模板显式实参</h3><ul>
<li>某些情况下，编译器无法推断出模板实参的类型。</li>
<li>定义：<code>template &lt;typename T1, typename T2, typename T3&gt; T1 sum(T2, T3);</code></li>
<li>使用函数显式实参调用：<code>auto val3 = sum&lt;long long&gt;(i, lng); // T1是显式指定，T2和T3都是从函数实参类型推断而来</code></li>
<li><strong>注意</strong>：正常类型转换可以应用于显式指定的实参。</li>
</ul>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><ul>
<li>使用场景：并不清楚返回结果的准确类型，但知道所需类型是和参数相关的。</li>
<li><code>template &lt;typename It&gt; auto fcn(It beg, It end) -&gt; decltype(*beg)</code></li>
<li>尾置返回允许我们在参数列表之后声明返回类型。</li>
</ul>
<p>标准库的<strong>类型转换</strong>模板：</p>
<ul>
<li>定义在头文件<code>type_traits</code>中。</li>
</ul>
<table>
<thead>
<tr>
<th>对<code>Mod&lt;T&gt;</code>，其中<code>Mod</code>是：</th>
<th>若<code>T</code>是：</th>
<th>则<code>Mod&lt;T&gt;::type</code>是：</th>
</tr>
</thead>
<tbody><tr>
<td><code>remove_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_const</code></td>
<td><code>X&amp;</code>或<code>const X</code>或函数</td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>const T</code></td>
</tr>
<tr>
<td><code>add_lvalue_reference</code></td>
<td><code>X&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td><code>X&amp;&amp;</code></td>
<td><code>X&amp;</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;</code></td>
</tr>
<tr>
<td><code>add_rvalue_reference</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>T</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T&amp;&amp;</code></td>
</tr>
<tr>
<td><code>remove_pointer</code></td>
<td><code>X*</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>add_pointer</code></td>
<td><code>X&amp;</code>或<code>X&amp;&amp;</code></td>
<td><code>X*</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T*</code></td>
</tr>
<tr>
<td><code>make_signed</code></td>
<td><code>unsigned X</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>make_unsigned</code></td>
<td>带符号类型</td>
<td><code>unsigned X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_extent</code></td>
<td><code>X[n]</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
<tr>
<td><code>remove_all_extents</code></td>
<td><code>X[n1][n2]...</code></td>
<td><code>X</code></td>
</tr>
<tr>
<td></td>
<td>否则</td>
<td><code>T</code></td>
</tr>
</tbody></table>
<h3 id="函数指针和实参推断"><a href="#函数指针和实参推断" class="headerlink" title="函数指针和实参推断"></a>函数指针和实参推断</h3><ul>
<li>当使用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</li>
</ul>
<h3 id="模板实参推断和引用"><a href="#模板实参推断和引用" class="headerlink" title="模板实参推断和引用"></a>模板实参推断和引用</h3><ul>
<li>从左值引用函数推断类型：若形如<code>T&amp;</code>，则只能传递给它一个左值。但如果是<code>const T&amp;</code>，则可以接受一个右值。</li>
<li>从右值引用函数推断类型：若形如<code>T&amp;&amp;</code>，则只能传递给它一个右值。</li>
<li>引用折叠和右值引用参数：<ul>
<li>规则1：当我们将一个左值传递给函数的右值引用参数，且右值引用指向模板类型参数时（如<code>T&amp;&amp;</code>），编译器会推断模板类型参数为实参的左值引用类型。</li>
<li>规则2：如果我们间接创造一个引用的引用，则这些引用形成了<strong>折叠</strong>。折叠引用只能应用在间接创造的引用的引用，如类型别名或模板参数。对于一个给定类型<code>X</code>：<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>和<code>X&amp;&amp; &amp;</code>都折叠成类型<code>X&amp;</code>。</li>
<li>类型<code>X&amp;&amp; &amp;&amp;</code>折叠成<code>X&amp;&amp;</code>。</li>
</ul>
</li>
<li>上面两个例外规则导致两个重要结果：<ul>
<li>1.如果一个函数参数是一个指向模板类型参数的右值引用（如<code>T&amp;&amp;</code>），则它可以被绑定到一个左值上；</li>
<li>2.如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个左值引用参数（<code>T&amp;</code>）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="理解std-move"><a href="#理解std-move" class="headerlink" title="理解std::move"></a>理解std::move</h3><ul>
<li>标准库<code>move</code>函数是使用右值引用的模板的一个很好的例子。</li>
<li>从一个左值<code>static_cast</code>到一个右值引用是允许的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><ul>
<li>使用一个名为<code>forward</code>的新标准库设施来传递参数，它能够保持原始实参的类型。</li>
<li>定义在头文件<code>utility</code>中。</li>
<li>必须通过显式模板实参来调用。</li>
<li><code>forward</code>返回显式实参类型的右值引用。即，<code>forward&lt;T&gt;</code>的返回类型是<code>T&amp;&amp;</code>。</li>
</ul>
<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><ul>
<li>多个可行模板：当有多个重载模板对一个调用提供同样好的匹配时，会选择最特例化的版本。</li>
<li>非模板和模板重载：对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</li>
</ul>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p><strong>可变参数模板</strong>就是一个接受可变数目参数的模板函数或模板类。</p>
<ul>
<li>可变数目的参数被称为参数包。<ul>
<li>模板参数包：标识另个或多个模板参数。</li>
<li>函数参数包：标识另个或者多个函数参数。</li>
</ul>
</li>
<li>用一个省略号来指出一个模板参数或函数参数，表示一个包。</li>
<li><code>template &lt;typename T, typename... Args&gt;</code>，<code>Args</code>第一个模板参数包。</li>
<li><code>void foo(const T &amp;t, const Args&amp; ... rest);</code>，<code>rest</code>是一个函数参数包。</li>
<li><code>sizeof...</code>运算符，返回参数的数目。</li>
</ul>
<h3 id="编写可变参数函数模板"><a href="#编写可变参数函数模板" class="headerlink" title="编写可变参数函数模板"></a>编写可变参数函数模板</h3><ul>
<li>可变参数函数通常是递归的：第一步调用处理包中的第一个实参，然后用剩余实参调用自身。</li>
</ul>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><ul>
<li>对于一个参数包，除了获取它的大小，唯一能做的事情就是<strong>扩展</strong>（expand）。</li>
<li>扩展一个包时，还要提供用于每个扩展元素的<strong>模式</strong>（pattern）。</li>
</ul>
<h3 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h3><ul>
<li>新标准下可以组合使用可变参数模板和<code>forward</code>机制，实现将实参不变地传递给其他函数。</li>
</ul>
<h2 id="模板特例化（Specializations）"><a href="#模板特例化（Specializations）" class="headerlink" title="模板特例化（Specializations）"></a>模板特例化（Specializations）</h2><ul>
<li>定义函数模板特例化：关键字<code>template</code>后面跟一个空尖括号对（<code>&lt;&gt;</code>）。</li>
<li>特例化的本质是实例化一个模板，而不是重载它。特例化不影响函数匹配。</li>
<li>模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是特例化版本。</li>
<li>我们可以部分特例化类模板，但不能部分特例化函数模板。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/02/C-Primer-5th-16/" data-id="cmbc76op0000ikmq4bsc55y4e" data-title="C++ Primer 5th 16" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C-Primer-5th-15" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Hexo-Blog/2025/02/02/C-Primer-5th-15/" class="article-date">
  <time class="dt-published" datetime="2025-02-02T14:03:29.000Z" itemprop="datePublished">2025-02-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/Hexo-Blog/categories/C-Primer-5th/">C++ Primer 5th</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Hexo-Blog/2025/02/02/C-Primer-5th-15/">C++ Primer 5th 15</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h1><h2 id="OOP：概述"><a href="#OOP：概述" class="headerlink" title="OOP：概述"></a>OOP：概述</h2><ul>
<li>面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。</li>
<li><strong>继承</strong>（inheritance）：<ul>
<li>通过继承联系在一起的类构成一种层次关系。</li>
<li>通常在层次关系的根部有一个<strong>基类</strong>（base class）。</li>
<li>其他类直接或者简介从基类继承而来，这些继承得到的类成为<strong>派生类</strong>（derived class）。</li>
<li>基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。</li>
<li>对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtual function）。</li>
<li>派生类必须通过使用<strong>类派生列表</strong>（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。<code>class Bulk_quote : public Quote&#123;&#125;;</code></li>
<li>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li>
</ul>
</li>
<li><strong>动态绑定</strong>（dynamic binding，又称运行时绑定）：<ul>
<li>使用同一段代码可以分别处理基类和派生类的对象。</li>
<li>函数的运行版本由实参决定，即在运行时选择函数的版本。</li>
</ul>
</li>
</ul>
<h2 id="定义基类和派生类"><a href="#定义基类和派生类" class="headerlink" title="定义基类和派生类"></a>定义基类和派生类</h2><h3 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h3><ul>
<li>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</li>
<li>基类通过在其成员函数的声明语句前加上关键字<code>virtual</code>使得该函数执行<strong>动态绑定</strong>。</li>
<li>如果成员函数没有被声明为虚函数，则解析过程发生在编译时而非运行时。</li>
<li>访问控制：<ul>
<li><code>protected</code> ： 基类和和其派生类还有友元可以访问。</li>
<li><code>private</code> ： 只有基类本身和友元可以访问。</li>
</ul>
</li>
</ul>
<h3 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h3><ul>
<li>派生类必须通过类派生列表（class derivation list）明确指出它是从哪个基类继承而来。形式：冒号，后面紧跟以逗号分隔的基类列表，每个基类前面可以有一下三种访问说明符的一个：<code>public</code>、<code>protected</code>、<code>private</code>。</li>
<li>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li>
<li>派生类构造函数：派生类必须使用基类的构造函数去初始化它的基类部分。</li>
<li>静态成员：如果基类定义了一个基类成员，则在整个继承体系中只存在该成员的唯一定义。</li>
<li>派生类的声明：声明中不包含它的派生列表。</li>
<li>C++11新标准提供了一种防止继承的方法，在类名后面跟一个关键字<code>final</code>。</li>
</ul>
<h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><ul>
<li>理解基类和派生类之间的类型抓换是理解C++语言面向对象编程的关键所在。</li>
<li>可以将基类的指针或引用绑定到派生类对象上。</li>
<li>不存在从基类向派生类的隐式类型转换。</li>
<li>派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。</li>
</ul>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><ul>
<li>使用虚函数可以执行动态绑定。</li>
<li>OOP的核心思想是多态性（polymorphism）。</li>
<li>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</li>
<li>派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上<code>virtual</code>关键字，也可以不加。</li>
<li>C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个<code>override</code>关键字。</li>
<li>如果我们想覆盖某个虚函数，但不小心把形参列表弄错了，这个时候就不会覆盖基类中的虚函数。加上<code>override</code>可以明确程序员的意图，让编译器帮忙确认参数列表是否出错。</li>
<li>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</li>
<li>通常，只有成员函数（或友元）中的代码才需要使用<strong>作用域运算符</strong>（<code>::</code>）来回避虚函数的机制。</li>
</ul>
<h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><ul>
<li><strong>纯虚函数</strong>（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写<code>=0</code>就可以将一个虚函数说明为纯虚函数。</li>
<li>含有纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。不能创建抽象基类的对象。</li>
</ul>
<h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ul>
<li>受保护的成员：<ul>
<li><code>protected</code>说明符可以看做是<code>public</code>和<code>private</code>中的产物。</li>
<li>类似于私有成员，受保护的成员对类的用户来说是不可访问的。</li>
<li>类似于公有成员，受保护的成员对于派生类的成员和友元来说是可访问的。</li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li>
</ul>
</li>
<li>派生访问说明符：<ul>
<li>对于派生类的成员（及友元）能否访问其直接积累的成员没什么影响。</li>
<li>派生访问说明符的目的是：控制派生类用户对于基类成员的访问权限。比如<code>struct Priv_Drev: private Base&#123;&#125;</code>意味着在派生类<code>Priv_Drev</code>中，从<code>Base</code>继承而来的部分都是<code>private</code>的。</li>
</ul>
</li>
<li>友元关系不能继承。</li>
<li>改变个别成员的可访问性：使用<code>using</code>。</li>
<li>默认情况下，使用<code>class</code>关键字定义的派生类是私有继承的；使用<code>struct</code>关键字定义的派生类是公有继承的。</li>
</ul>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><ul>
<li>每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。</li>
<li>派生类的成员将隐藏同名的基类成员。</li>
<li>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</li>
</ul>
<h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul>
<li>基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。</li>
<li>如果基类的析构函数不是虚函数，则<code>delete</code>一个指向派生类对象的基类指针将产生未定义的行为。</li>
<li>虚析构函数将阻止合成移动操作。</li>
</ul>
<h3 id="合成拷贝控制与继承"><a href="#合成拷贝控制与继承" class="headerlink" title="合成拷贝控制与继承"></a>合成拷贝控制与继承</h3><ul>
<li>基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。</li>
</ul>
<h3 id="派生类的拷贝控制成员"><a href="#派生类的拷贝控制成员" class="headerlink" title="派生类的拷贝控制成员"></a>派生类的拷贝控制成员</h3><ul>
<li>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</li>
<li>派生类析构函数：派生类析构函数先执行，然后执行基类的析构函数。</li>
</ul>
<h3 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h3><ul>
<li>C++11新标准中，派生类可以重用其直接基类定义的构造函数。</li>
<li>如<code>using Disc_quote::Disc_quote;</code>，注明了要继承<code>Disc_quote</code>的构造函数。</li>
</ul>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><ul>
<li>当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。</li>
<li>派生类对象直接赋值给积累对象，其中的派生类部分会被切掉。</li>
<li>在容器中放置（智能）指针而非对象。</li>
<li>对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这些复杂的情况。</li>
</ul>
<h2 id="文本查询程序再探"><a href="#文本查询程序再探" class="headerlink" title="文本查询程序再探"></a>文本查询程序再探</h2><ul>
<li>使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。</li>
</ul>
<h3 id="面向对象的解决方案"><a href="#面向对象的解决方案" class="headerlink" title="面向对象的解决方案"></a>面向对象的解决方案</h3><ul>
<li>将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：<ul>
<li><code>WordQuery</code></li>
<li><code>NotQuery</code></li>
<li><code>OrQuery</code></li>
<li><code>AndQuery</code></li>
</ul>
</li>
<li>这些类包含两个操作：<ul>
<li><code>eval</code>：接受一个<code>TextQuery</code>对象并返回一个<code>QueryResult</code>。</li>
<li><code>rep</code>：返回基础查询的<code>string</code>表示形式。</li>
</ul>
</li>
<li>继承和组合：<ul>
<li>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。</li>
<li>类型之间另一种常见的关系是“有一个（Has A）”的关系。</li>
</ul>
</li>
<li>对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。</li>
</ul>
<p><strong>Query程序设计</strong>:</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>Query</code>程序接口类和操作</td>
<td></td>
</tr>
<tr>
<td><code>TextQuery</code></td>
<td>该类读入给定的文件并构建一个查找图。包含一个<code>query</code>操作，它接受一个<code>string</code>实参，返回一个<code>QueryResult</code>对象；该<code>QueryResult</code>对象表示<code>string</code>出现的行。</td>
</tr>
<tr>
<td><code>QueryResult</code></td>
<td>该类保存一个<code>query</code>操作的结果。</td>
</tr>
<tr>
<td><code>Query</code></td>
<td>是一个接口类，指向<code>Query_base</code>派生类的对象。</td>
</tr>
<tr>
<td><code>Query q(s)</code></td>
<td>将<code>Query</code>对象<code>q</code>绑定到一个存放着<code>string s</code>的新<code>WordQuery</code>对象上。</td>
</tr>
<tr>
<td><code>q1 &amp; q2</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q1</code>和<code>q2</code>的新<code>AndQuery</code>对象上。</td>
</tr>
<tr>
<td>&#96;q1</td>
<td>q2&#96;</td>
</tr>
<tr>
<td><code>~q</code></td>
<td>返回一个<code>Query</code>对象，该<code>Query</code>绑定到一个存放<code>q</code>的新<code>NotQuery</code>对象上。</td>
</tr>
<tr>
<td><code>Query</code>程序实现类</td>
<td></td>
</tr>
<tr>
<td><code>Query_base</code></td>
<td>查询类的抽象基类</td>
</tr>
<tr>
<td><code>WordQuery</code></td>
<td><code>Query_base</code>的派生类，用于查找一个给定的单词</td>
</tr>
<tr>
<td><code>NotQuery</code></td>
<td><code>Query_base</code>的派生类，用于查找一个给定的单词</td>
</tr>
<tr>
<td><code>BinaryQuery</code></td>
<td><code>Query_base</code>的派生类，查询结果是<code>Query</code>运算对象没有出现的行的集合</td>
</tr>
<tr>
<td><code>OrQuery</code></td>
<td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的并集</td>
</tr>
<tr>
<td><code>AndQuery</code></td>
<td><code>Query_base</code>的派生类，返回它的两个运算对象分别出现的行的交集</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://yingjuhan.github.io/Hexo-Blog/2025/02/02/C-Primer-5th-15/" data-id="cmbc76ooy000dkmq4ee0ah4nx" data-title="C++ Primer 5th 15" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo-Blog/tags/C/" rel="tag">C++</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/Hexo-Blog/page/2/">2</a><a class="page-number" href="/Hexo-Blog/page/3/">3</a><a class="extend next" rel="next" href="/Hexo-Blog/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/Hexo-Blog/categories/C-Primer-5th/">C++ Primer 5th</a></li><li class="category-list-item"><a class="category-list-link" href="/Hexo-Blog/categories/C-C-%E5%9F%BA%E7%A1%80/">C/C++基础</a></li><li class="category-list-item"><a class="category-list-link" href="/Hexo-Blog/categories/IO/">IO</a></li><li class="category-list-item"><a class="category-list-link" href="/Hexo-Blog/categories/curriculum-vitae/">curriculum vitae</a></li><li class="category-list-item"><a class="category-list-link" href="/Hexo-Blog/categories/opencascade/">opencascade</a></li><li class="category-list-item"><a class="category-list-link" href="/Hexo-Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/Hexo-Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/3d/" rel="tag">3d</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/C-C-%E5%9F%BA%E7%A1%80/" rel="tag">C&#x2F;C++基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/MSVC/" rel="tag">MSVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/MinGW/" rel="tag">MinGW</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/buffer/" rel="tag">buffer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/file-io/" rel="tag">file io</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/opencascade/" rel="tag">opencascade</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">动态链接库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/%E5%BB%BA%E6%A8%A1/" rel="tag">建模</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/%E5%BC%80%E5%8F%91/" rel="tag">开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo-Blog/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" rel="tag">静态链接库</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/Hexo-Blog/tags/3d/" style="font-size: 10px;">3d</a> <a href="/Hexo-Blog/tags/C/" style="font-size: 20px;">C++</a> <a href="/Hexo-Blog/tags/C-C-%E5%9F%BA%E7%A1%80/" style="font-size: 15px;">C/C++基础</a> <a href="/Hexo-Blog/tags/MSVC/" style="font-size: 10px;">MSVC</a> <a href="/Hexo-Blog/tags/MinGW/" style="font-size: 10px;">MinGW</a> <a href="/Hexo-Blog/tags/buffer/" style="font-size: 10px;">buffer</a> <a href="/Hexo-Blog/tags/file-io/" style="font-size: 10px;">file io</a> <a href="/Hexo-Blog/tags/opencascade/" style="font-size: 10px;">opencascade</a> <a href="/Hexo-Blog/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" style="font-size: 15px;">动态链接库</a> <a href="/Hexo-Blog/tags/%E5%BB%BA%E6%A8%A1/" style="font-size: 10px;">建模</a> <a href="/Hexo-Blog/tags/%E5%BC%80%E5%8F%91/" style="font-size: 10px;">开发</a> <a href="/Hexo-Blog/tags/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/" style="font-size: 15px;">静态链接库</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Hexo-Blog/archives/2025/05/">May 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Hexo-Blog/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Hexo-Blog/archives/2025/01/">January 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Hexo-Blog/2025/05/30/flatbuffers/">flatbuffers</a>
          </li>
        
          <li>
            <a href="/Hexo-Blog/2025/02/10/MSVC%E4%B8%8EMinGW/">MSVC与MinGW</a>
          </li>
        
          <li>
            <a href="/Hexo-Blog/2025/02/09/a%E5%92%8Cso%E7%9A%84%E7%AE%80%E4%BB%8B-3-Linux-GNU/">.a和so的简介 (3. Linux GNU)</a>
          </li>
        
          <li>
            <a href="/Hexo-Blog/2025/02/09/DLL-a%E5%92%8CDLL%E7%9A%84%E7%AE%80%E4%BB%8B-2-Windows-MINGW/">DLL.a和DLL的简介 (2. Windows MINGW)</a>
          </li>
        
          <li>
            <a href="/Hexo-Blog/2025/02/09/LIB%E5%92%8CDLL%E7%9A%84%E7%AE%80%E4%BB%8B/">LIB和DLL的简介 (1. Windows MSVC)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 YingjuHan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/Hexo-Blog/" class="mobile-nav-link">Home</a>
  
    <a href="/Hexo-Blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/Hexo-Blog/js/jquery-3.6.4.min.js"></script>



  
<script src="/Hexo-Blog/fancybox/jquery.fancybox.min.js"></script>




<script src="/Hexo-Blog/js/script.js"></script>





  </div>
</body>
</html>